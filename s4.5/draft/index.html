<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>MODOK League S4.5 Hero Pool Builder - Enhanced</title>
 <style>
   * {
     margin: 0;
     padding: 0;
     box-sizing: border-box;
   }

   body {
     background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
     background-size: 400% 400%;
     animation: comicBg 15s ease infinite;
     color: #2c2c54;
     font-family: 'Comic Sans MS', 'Comic Sans', 'Chalkboard SE', 'Marker Felt', sans-serif;
     transition: all 0.3s ease;
     min-height: 100vh;
   }

   @keyframes comicBg {
     0% { background-position: 0% 50%; }
     50% { background-position: 100% 50%; }
     100% { background-position: 0% 50%; }
   }

   .container {
     max-width: 1200px;
     margin: 0 auto;
     padding: 20px;
     background: rgba(255, 255, 255, 0.95);
     border: 4px solid #2c2c54;
     border-radius: 20px;
     position: relative;
     box-shadow: 0 20px 40px rgba(0,0,0,0.1);
     margin-top: 20px;
     margin-bottom: 20px;
   }

   .container::before {
     content: '';
     position: absolute;
     top: -10px;
     left: -10px;
     right: -10px;
     bottom: -10px;
     background: repeating-linear-gradient(
       45deg,
       #ff6b6b,
       #ff6b6b 10px,
       #feca57 10px,
       #feca57 20px
     );
     border-radius: 25px;
     z-index: -1;
   }

   .header {
     text-align: center;
     margin-bottom: 30px;
   }

   .header h1 {
     font-size: 2.5rem;
     margin-bottom: 10px;
     font-weight: 700;
   }

   .controls {
     display: grid;
     grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
     gap: 20px;
     margin-bottom: 30px;
   }

   .control-group {
     display: flex;
     flex-direction: column;
     gap: 8px;
   }

   .control-group label {
     font-weight: 600;
     font-size: 1rem;
   }

   .control-group input, .control-group select, .control-group textarea {
     padding: 12px;
     border: 2px solid #ddd;
     border-radius: 8px;
     font-size: 1rem;
     transition: all 0.3s ease;
   }

   .control-group input:focus, .control-group select:focus, .control-group textarea:focus {
     outline: none;
     border-color: #4a90e2;
     box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
   }

   .btn {
     padding: 15px 30px;
     background: linear-gradient(145deg, #ff6b6b, #ee5a52);
     color: white;
     border: 3px solid #2c2c54;
     border-radius: 8px;
     font-size: 1.1rem;
     font-weight: bold;
     cursor: pointer;
     transition: all 0.3s ease;
     text-transform: uppercase;
     letter-spacing: 1px;
   }

   .btn:hover {
     background: linear-gradient(145deg, #ee5a52, #e54646);
     transform: translateY(-2px);
     box-shadow: 0 10px 20px rgba(0,0,0,0.2);
   }

   .hero-lists {
     display: grid;
     grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
     gap: 20px;
     margin-bottom: 30px;
   }

   .hero-section {
     padding: 20px;
     border-radius: 10px;
     background: rgba(255,255,255,0.1);
     backdrop-filter: blur(5px);
   }

   .hero-section h3 {
     margin-bottom: 15px;
     font-size: 1.3rem;
     font-weight: 600;
   }

   .hero-grid {
     display: flex;
     flex-wrap: wrap;
     gap: 8px;
   }

   .hero-card {
     padding: 8px 12px;
     background: linear-gradient(145deg, #fff, #f0f0f0);
     border: 3px solid #2c2c54;
     border-radius: 6px;
     font-size: 0.9rem;
     transition: all 0.3s ease;
     cursor: default;
     transform: rotate(-1deg);
   }

   .hero-card:nth-child(even) {
     transform: rotate(1deg);
   }

   .hero-card:hover {
     transform: rotate(0deg) scale(1.05);
     box-shadow: 0 10px 20px rgba(0,0,0,0.3);
   }

   .trait-card-multiline {
     padding: 12px 15px;
     min-height: 80px;
     text-align: left;
     line-height: 1.3;
     display: flex;
     flex-direction: column;
     justify-content: flex-start;
   }

   .trait-card-multiline:hover {
     transform: rotate(0deg) scale(1.03);
   }

   .trait-line {
     display: block;
     width: 100%;
   }

   .trait-character {
     font-weight: bold;
     font-size: 1.1em;
     margin-bottom: 4px;
     color: #2c2c54;
   }

   .trait-hero {
     font-size: 0.9em;
     margin-bottom: 2px;
     color: #444;
   }

   .trait-ae {
     font-size: 0.9em;
     color: #666;
   }

   .results {
     margin-top: 30px;
   }

   .result-section {
     margin-bottom: 25px;
     padding: 20px;
     border-radius: 10px;
     background: rgba(255,255,255,0.1);
     backdrop-filter: blur(5px);
   }

   .result-section h3 {
     margin-bottom: 15px;
     font-size: 1.3rem;
     font-weight: 600;
     color: #2c2c54;
   }

   .draft-order {
     display: grid;
     grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
     gap: 10px;
   }

   .kouple-card {
     padding: 12px;
     text-align: center;
     background: rgba(74, 144, 226, 0.1);
     border-radius: 8px;
     font-weight: 600;
     border: 2px solid rgba(74, 144, 226, 0.3);
   }

   .footer-note {
     margin-top: 30px;
     padding: 15px;
     background: rgba(0,0,0,0.1);
     border-radius: 8px;
     font-size: 0.9rem;
     text-align: center;
     display: none;
   }

   .footer-note a {
     color: #2c2c54;
     text-decoration: none;
     font-weight: 600;
   }

   .footer-note a:hover {
     text-decoration: underline;
   }

   @media (max-width: 768px) {
     .container {
       padding: 15px;
       margin: 10px;
     }
     
     .header h1 {
       font-size: 2rem;
     }
     
     .controls {
       grid-template-columns: 1fr;
     }
     
     .hero-lists {
       grid-template-columns: 1fr;
     }
   }
 </style>
</head>
<body>
 <div class="container">
   <div class="header">
     <h1>Draft-o-matic</h1>
     <p id="toolVersionDisplay">MODOK League Season 4.5</p>
   </div>

   <div class="hero-lists">
     <div class="hero-section">
       <h3>Available Heroes</h3>
       <div class="hero-grid" id="allHeroes"></div>
     </div>
     
     <div class="hero-section">
       <h3>Available Traits</h3>
       <div class="hero-grid" id="allTraits"></div>
     </div>
     
     <div class="hero-section">
       <h3>Banned Heroes</h3>
       <div class="hero-grid" id="bannedHeroes"></div>
     </div>
     
     <div class="hero-section">
       <h3>Banned Traits</h3>
       <div class="hero-grid" id="bannedTraits"></div>
     </div>
   </div>

   <div class="controls">
     <div class="control-group">
       <label for="draftPoolGroups">Number of Draft Groups</label>
       <small style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">Number of separate groups for heroes and traits</small>
       <select id="draftPoolGroups">
         <option value="6">6 (3 hero, 3 traits, 6 picks)</option>
         <option value="4">4 (2 hero, 2 traits, 4 picks)</option>
       </select>
     </div>
     
     <div class="control-group">
       <label for="teamsInput">Number of Kouples</label>
       <small style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">Range: 6-14 kouples</small>
       <input type="number" id="teamsInput" min="6" max="14" value="10">
     </div>
     
     <div class="control-group">
       <label for="extrasInput">Extra Choices per Draft Pool Group</label>
       <small id="extrasSubLabel" style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">Beyond the mininum number needed for drafting (Maximum: <span id="maxExtras">45</span>)</small>
       <input type="number" id="extrasInput" min="0" max="45" value="3">
     </div>
     
     
     <div class="control-group">
       <label for="teamListInput">Kouple Names (Optional)</label>
       <small style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">One kouple per line. <strong>First will be your kouple</strong> in the draft simulator. Remaining names replace default kouple names.</small>
       <textarea id="teamListInput" placeholder="My Kouple Name&#10;Kouple Beta&#10;Kouple Gamma&#10;..." style="padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; resize: vertical; min-height: 80px; font-family: inherit;"></textarea>
     </div>
     
     <div class="control-group">
       <label for="seedInput">Seed for Randomization (Optional)</label>
       <input type="text" id="seedInput" placeholder="For reproducible results">
     </div>
   </div>

   <div style="text-align: center;">
     <button class="btn" id="goButton">Generate Draft Pool</button>
   </div>

   <div class="results" id="results" style="display: none;">
     <div class="result-section">
       <h3>Hero Pool</h3>
       <div class="hero-grid" id="resultPool"></div>
     </div>
     
     <div class="result-section">
       <h3>Traits Pool</h3>
       <div class="hero-grid" id="resultTraitsPool"></div>
     </div>
     
     <div class="result-section">
       <h3>Draft Bot Priority (Heroes)</h3>
       <div class="hero-grid" id="resultDraftBot"></div>
     </div>
     
     <div class="result-section">
       <h3>Draft Bot Priority (Traits)</h3>
       <div class="hero-grid" id="resultDraftBotTraits"></div>
     </div>
     
     <div class="result-section">
       <h3>Kouple Draft Order</h3>
       <div class="draft-order" id="resultDraftOrder"></div>
     </div>
     
     <div class="result-section">
       <h3>Excluded Heroes</h3>
       <div class="hero-grid" id="resultExcluded"></div>
     </div>
     
     <div class="result-section">
       <h3>Excluded Traits</h3>
       <div class="hero-grid" id="resultExcludedTraits"></div>
     </div>
     
     <div style="text-align: center; margin-top: 30px; padding: 20px;">
       <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2;">
         <h4 style="margin-bottom: 15px; color: #8A2BE2;">Bot Strategy Settings</h4>
         
         <div style="margin-bottom: 20px;">
           <label for="botRandomnessSlider" style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c2c54;">
             Bot Ignore Round Preferences: <span id="botRandomnessValue" style="color: #8A2BE2;">15%</span>
           </label>
           <input type="range" id="botRandomnessSlider" min="0" max="100" value="15" style="width: 300px; max-width: 100%;" oninput="updateBotSettings()">
           <div style="display: flex; justify-content: space-between; max-width: 300px; margin: 5px auto 0; font-size: 0.8em; color: #666;">
             <span>0% (Predictable)</span>
             <span>50% (Balanced)</span>
             <span>100% (Chaotic)</span>
           </div>
           <p id="roundPreferencesText" style="font-size: 0.85em; color: #666; margin: 8px 0 0; text-align: center;">Chance to ignore round preferences (Hero R1&3, Traits R2&4)</p>
         </div>
         
         <div style="margin-bottom: 15px;">
           <label for="botSurpriseSlider" style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c2c54;">
             Bot Surprise Pick: <span id="botSurpriseValue" style="color: #ff6b6b;">10%</span>
           </label>
           <input type="range" id="botSurpriseSlider" min="0" max="100" value="10" style="width: 300px; max-width: 100%;" oninput="updateBotSettings()">
           <div style="display: flex; justify-content: space-between; max-width: 300px; margin: 5px auto 0; font-size: 0.8em; color: #666;">
             <span>0% (Tier List Only)</span>
             <span>50% (Mixed)</span>
             <span>100% (Pure Random)</span>
           </div>
           <p style="font-size: 0.85em; color: #666; margin: 8px 0 0; text-align: center;">Chance to ignore tier lists and pick completely randomly</p>
         </div>
         
         <p id="botStrategyDescription" style="color: #2c2c54; font-size: 0.9rem; margin: 0; text-align: center; font-style: italic; background: rgba(255,255,255,0.3); padding: 10px; border-radius: 6px;">
           Bots prefer Hero in R1&3, Traits in R2&4, with 15% chance to draft opposite type. 5% chance for surprise picks.
         </p>
       </div>
       
       <button class="btn" id="exportButton" onclick="exportDraftPool()" style="font-size: 1rem; padding: 12px 25px; margin-right: 15px;">
         ðŸ“‹ Export Draft Pool
       </button>
       <button class="btn" id="startDraftButton" onclick="startDraftSimulator()" style="font-size: 1rem; padding: 12px 25px;">
         ðŸŽ¯ Start Draft Simulator
       </button>
     </div>
   </div>

   <div class="draft-setup" id="draftSetup" style="display: none;">
     <div class="result-section">
       <h3>ðŸŽ¯ Draft Simulator - Setup</h3>
       <div style="padding: 20px;">
         <div style="background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #ff6b6b;">
           <h4 style="margin-bottom: 10px; color: #ff6b6b;">Your Kouple</h4>
<p style="font-size: 1.2rem; font-weight: bold;" id="playerTeamDisplay"></p>
         </div>
         
         <div style="background: rgba(72, 219, 251, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #48dbfb;">
           <h4 style="margin-bottom: 15px; color: #48dbfb;">Draft Information</h4>
           <p style="margin-bottom: 10px;">Heroes available for draft: <strong id="heroCountDisplay"></strong></p>
           <p style="margin-bottom: 10px;">Traits available for draft: <strong id="traitsCountDisplay"></strong></p>
           <p>Kouples participating: <strong id="teamCountDisplay"></strong></p>
           <p id="draftDescription" style="margin-top: 10px; font-size: 0.9rem; color: #666;">Each team drafts 2 heroes and 2 traits over 4 rounds</p>
         </div>
         
         <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2; text-align: center;">
           <h4 style="margin-bottom: 10px; color: #8A2BE2; font-size: 1.2rem;">Current Draft Status</h4>
           <p id="draftStatusMessage2" style="font-size: 1.1rem; font-weight: bold; color: #2c2c54;">ðŸŽ¯ Your Turn - Click a hero or aspect to draft!</p>
           <p id="draftConstraintMessage2" style="font-size: 0.9rem; color: #666; margin-top: 8px;"></p>
         </div>
         
         <div style="background: rgba(160, 160, 160, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #a0a0a0;">
           <h4 style="margin-bottom: 15px; color: #2c2c54;">All Kouples' Picks (Draft Order)</h4>
           <div id="allTeamsPicksDisplay">
             <p style="color: #666; font-style: italic;">Draft not started</p>
           </div>
         </div>
         
         <div style="background: rgba(254, 202, 87, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 30px; border: 2px solid #feca57;">
           <h4 style="margin-bottom: 15px; color: #2c2c54;">Kouple Draft Order</h4>
           <div id="draftOrderDisplay" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;"></div>
         </div>
         
         <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2; text-align: center;">
           <h4 style="margin-bottom: 10px; color: #8A2BE2; font-size: 1.2rem;">Draft Status</h4>
           <p id="draftStatusMessage" style="font-size: 1.1rem; font-weight: bold; color: #2c2c54;">ðŸŽ¯ Your Turn - Click a hero or aspect to draft!</p>
           <p id="draftConstraintMessage" style="font-size: 0.9rem; color: #666; margin-top: 8px;"></p>
         </div>
         
         <div style="background: rgba(144, 238, 144, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #90EE90;">
           <h4 style="margin-bottom: 15px; color: #2c2c54;">Available Heroes for Draft</h4>
           <div id="availableHeroesDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
         </div>
         
         <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #ffc107;">
           <h4 style="margin-bottom: 15px; color: #2c2c54;">Available Traits for Draft</h4>
           <div id="availableTraitsDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
         </div>
         
         <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2;">
           <h4 style="margin-bottom: 15px; color: #2c2c54;">Bot Priority (Heroes)</h4>
           <div id="botPriorityDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
         </div>
         
         <div style="background: rgba(255, 20, 147, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #ff1493;">
           <h4 style="margin-bottom: 15px; color: #2c2c54;">Bot Priority (Traits)</h4>
           <div id="botTraitsPriorityDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
         </div>
         
         <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 30px; border: 1px solid #ffc107;">
           <p id="draftRulesText" style="color: #2c2c54; font-size: 0.9rem; margin: 0; text-align: center;">
             <strong>Draft Rules:</strong> 4 rounds total. Each team picks 2 heroes and 2 traits. You can choose heroes or traits freely within constraints.<br>
             <strong>Group Restrictions (4-group mode):</strong> Each team can only draft one hero from each hero group AND one traits from each traits group. Second picks must be from opposite groups.<br>
             <strong>Bot Strategy:</strong> Three-stage system - 1) Check round preferences, 2) Check for surprise picks (random), 3) Use strategic selection.<br>
             <strong>Round Preferences:</strong> Bots prefer Hero in R1&R3, Traits in R2&R4. "Bot Ignore Round Preferences" slider controls chance to draft opposite type.<br>
             <strong>Hero Priority:</strong> Bots use weighted selection from tier list (~38% top choice, ~26% 2nd choice, etc.). Surprise picks ignore tier lists.<br>
             <strong>Traits Priority:</strong> Random priority order set once per draft generation, then weighted selection from priority list.<br>
             <strong>Surprise Picks:</strong> Completely random selection that ignores both tier lists and Leadership priority. Controlled by separate slider.
           </p>
         </div>
       </div>
     </div>
   </div>

   <div class="footer-note" id="footerNote">
     Draft-bot order is based on <a href="https://www.youtube.com/watch?v=2bRm-ZxtNjM" target="_blank">Villain Theory's May 2025 tierlist</a>
   </div>
 </div>

 <script>
   /* ===== MODOK DRAFT TOOL - MAIN SCRIPT START ===== */
   // CRITICAL: All JavaScript code must remain within this script block
   
   // Dynamic pool aspect count with equal hero/aspect totals
   // Pool is 50% as likely to be added to draft pool as the other aspects
   var TOOL_VERSION = 'V0.6';
  var DEFAULT_DRAFT_GROUPS = '6';
   
   // Initialize version displays
   document.addEventListener('DOMContentLoaded', function() {
     document.getElementById('toolVersionDisplay').textContent = 'MODOK League Season 4.5 (' + TOOL_VERSION + ')';
   });
   
   // Error boundary wrapper for critical functions - Available globally
   function safeExecute(fn, context, args, functionName) {
     try {
       return fn.apply(context, args || []);
     } catch (error) {
       return null;
     }
   }
   
   // Runtime validation and error protection
   (function() {
     'use strict';
     
     // Validate HTML structure integrity
     function validateStructure() {
       try {
         var requiredElements = ['allHeroes', 'allTraits', 'bannedHeroes', 'bannedTraits', 'goButton', 'results'];
         var missing = [];
         
         for (var i = 0; i < requiredElements.length; i++) {
           if (!document.getElementById(requiredElements[i])) {
             missing.push(requiredElements[i]);
           }
         }
         
         if (missing.length > 0) {
           return false;
         }
         
         return true;
       } catch (error) {
         return false;
       }
     }
     
     // Validate script execution at end
     window.validateScriptExecution = function() {
       var checks = [
         { name: 'HTML Structure', test: validateStructure },
         { name: 'Global Variables', test: function() { return typeof marvelHeroes !== 'undefined'; } },
         { name: 'Main Functions', test: function() { return typeof updateBotSettings === 'function'; } }
       ];
       
       var passed = 0;
       var total = checks.length;
       
       for (var i = 0; i < checks.length; i++) {
         var check = checks[i];
         var result = check.test();
         if (result) passed++;
       }
       
       if (passed === total) {
         return true;
       } else {
         return false;
       }
     };
     
     // Auto-validate on DOM ready
     if (document.readyState === 'loading') {
       document.addEventListener('DOMContentLoaded', function() {
         setTimeout(window.validateScriptExecution, 100);
       });
     } else {
       setTimeout(window.validateScriptExecution, 100);
     }
     
   })();
   
   // Global variables
   var traitsPriorityList = [];
   var currentTurnIndex = 0;
   var currentRound = 1;
   var maxRounds = 4; // Will be updated based on draft mode
   var draftOrderTeams = [];
   var playerTeamName = '';
   var teamPicks = {};
   var isPlayerTurn = false;
   var draftedHeroes = [];
   var draftedTraits = [];
   var allHeroes = [];
   var allTraits = [];
   var botRandomnessPercentage = 15; // Default 15% randomness
   var botSurprisePercentage = 10; // Default 10% surprise picks
   var heroGroup1 = [];
   var heroGroup2 = [];
   var heroGroup3 = [];
   var traitsGroup1 = [];
   var traitsGroup2 = [];
   var traitsGroup3 = []; // Third traits group for 6-group mode

   // Update bot settings (both sliders)
   function updateBotSettings() {
     return safeExecute(function() {
       var randomnessSlider = document.getElementById('botRandomnessSlider');
       var surpriseSlider = document.getElementById('botSurpriseSlider');
       var randomnessValue = document.getElementById('botRandomnessValue');
       var surpriseValue = document.getElementById('botSurpriseValue');
       var description = document.getElementById('botStrategyDescription');
       
       botRandomnessPercentage = parseInt(randomnessSlider.value);
       botSurprisePercentage = parseInt(surpriseSlider.value);
       
       randomnessValue.textContent = botRandomnessPercentage + '%';
       surpriseValue.textContent = botSurprisePercentage + '%';
       
       // Generate combined strategy description
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       var roundText = '';
       
       if (draftPoolGroups === '6') {
         // Support for 6-group mode (H-A-H-A-H-A pattern)
         if (botRandomnessPercentage === 0) {
           roundText = 'Bots always follow strict pattern: Hero in R1&3&5, Traits in R2&4&6';
         } else if (botRandomnessPercentage <= 25) {
           roundText = 'Bots prefer Hero in R1&3&5, Traits in R2&4&6, with ' + botRandomnessPercentage + '% chance to draft opposite type';
         } else if (botRandomnessPercentage <= 75) {
           roundText = 'Bots have ' + botRandomnessPercentage + '% chance to ignore round preferences';
         } else {
           roundText = 'Bots draft randomly, ignoring round preferences (' + botRandomnessPercentage + '% randomness)';
         }
       } else {
         // Original logic for 4-group mode
         if (botRandomnessPercentage === 0) {
           roundText = 'Bots always follow strict pattern: Hero in R1&3, Traits in R2&4';
         } else if (botRandomnessPercentage <= 25) {
           roundText = 'Bots prefer Hero in R1&3, Traits in R2&4, with ' + botRandomnessPercentage + '% chance to draft opposite type';
         } else if (botRandomnessPercentage <= 75) {
           roundText = 'Bots have ' + botRandomnessPercentage + '% chance to ignore round preferences';
         } else {
           roundText = 'Bots mostly ignore round preferences (' + botRandomnessPercentage + '% chaos)';
         }
       }
       
       var surpriseText = '';
       if (botSurprisePercentage === 0) {
         surpriseText = 'Always use tier list priorities';
       } else if (botSurprisePercentage <= 10) {
         surpriseText = botSurprisePercentage + '% chance for shocking surprise picks';
       } else if (botSurprisePercentage <= 25) {
         surpriseText = botSurprisePercentage + '% chance to ignore tier lists completely';
       } else if (botSurprisePercentage <= 50) {
         surpriseText = botSurprisePercentage + '% chance for random picks (mixed strategy)';
       } else {
         surpriseText = botSurprisePercentage + '% chance for random picks (mostly chaos)';
       }
       
       description.textContent = roundText + '. ' + surpriseText + '.';
     }, null, [], 'updateBotSettings');
   }

   // Helper function to get hero group
   function getHeroGroup(heroName) {
     if (heroGroup1.includes(heroName)) {
       return 1;
     } else if (heroGroup2.includes(heroName)) {
       return 2;
     } else if (heroGroup3.includes(heroName)) {
       return 3;
     }
     return 0; // Not in any group
   }

   // Helper function to get aspect group
   function getAspectGroup(aspectName) {
     if (traitsGroup1.includes(aspectName)) {
       return 1;
     } else if (traitsGroup2.includes(aspectName)) {
       return 2;
     } else if (traitsGroup3.includes(aspectName)) {
       return 3; // Third aspect group for 6-group mode
     }
     return 0; // Not in any group
   }

   // Helper function to get aspect type summary
   function getAspectTypeSummary(aspectArray) {
     var typeCounts = {};
     aspectArray.forEach(function(aspect) {
       var aspectType = getAspectType(aspect);
       typeCounts[aspectType] = (typeCounts[aspectType] || 0) + 1;
     });
     
     var summaryParts = [];
     ['Aggression', 'Justice', 'Leadership', 'Protection', 'Pool'].forEach(function(type) {
       if (typeCounts[type]) {
         summaryParts.push(type + ': ' + typeCounts[type]);
       }
     });
     
     return summaryParts.join(', ');
   }

   // Helper function to get aspect type from numbered aspect
   function getAspectType(trait) {
     // Traits don't use numbered suffixes, return as-is
     return trait;
   }

   // Parse trait into 3 components for display
   function parseTraitForDisplay(trait) {
       try {
       // Extract character name with parentheses: (Character Name)
       var characterMatch = trait.match(/\([^)]+\)/);
       var characterName = characterMatch ? characterMatch[0] : '';
         
       // Extract hero traits: between "Hero: " and " - AE:"
       var heroMatch = trait.match(/Hero: (.*?) - AE:/);
       var heroTraits = heroMatch ? 'Hero: ' + heroMatch[1].trim() : '';
         
       // Extract alter-ego traits: after "AE: "
       var aeMatch = trait.match(/AE: (.+)$/);
       var aeTraits = aeMatch ? 'AE: ' + aeMatch[1].trim() : '';
         
       var result = {
         character: characterName,
         hero: heroTraits,
         alterEgo: aeTraits
       };
       return result;
     } catch (error) {
       return {
         character: trait,
         hero: '',
         alterEgo: ''
       };
     }
   }

   // Initialize aspect priority order
   function initializeTraitsPriorityOrder(useRandomSeed, rng) {
     // Initialize random priority order for all 54 traits
     traitsPriorityList = allTraits.slice(); // Copy all traits
     
     if (useRandomSeed && rng) {
       shuffleArray(traitsPriorityList, rng);
     } else {
       // Standard Fisher-Yates shuffle for random trait priority
       for (var i = traitsPriorityList.length - 1; i > 0; i--) {
         var j = Math.floor(Math.random() * (i + 1));
         var temp = traitsPriorityList[i];
         traitsPriorityList[i] = traitsPriorityList[j];
         traitsPriorityList[j] = temp;
       }
     }
     
   }

   // Helper function to get aspect type order for sorting
  function getAspectTypeOrder(aspectName) {
    var aspectTypes = ['Aggression', 'Justice', 'Leadership', 'Protection', 'Pool'];
    for (var i = 0; i < aspectTypes.length; i++) {
      if (aspectName.toLowerCase().includes(aspectTypes[i].toLowerCase())) {
        return i;
      }
    }
    return 999; // Non-aspect items go last
  }

  // Function to split hero pool into two groups for 4-group mode
   function splitHeroPoolIntoGroups(heroPool, rng) {
     var shuffledPool = heroPool.slice();
     shuffleArray(shuffledPool, rng);
     
     var midPoint = Math.floor(shuffledPool.length / 2);
     var group1 = shuffledPool.slice(0, midPoint).sort(function(a, b) {
      // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
      var typeOrderA = getAspectTypeOrder(a);
      var typeOrderB = getAspectTypeOrder(b);
      
      if (typeOrderA !== typeOrderB) {
        return typeOrderA - typeOrderB; // Sort by aspect type first
      }
      
      // Traits don't use numbered suffixes, use alphabetical sorting within same type
      return a.localeCompare(b);
    });
     var group2 = shuffledPool.slice(midPoint).sort(function(a, b) {
      // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
      var typeOrderA = getAspectTypeOrder(a);
      var typeOrderB = getAspectTypeOrder(b);
      
      if (typeOrderA !== typeOrderB) {
        return typeOrderA - typeOrderB; // Sort by aspect type first
      }
      
      // Traits don't use numbered suffixes, use alphabetical sorting within same type
      return a.localeCompare(b);
    });
     
     return { group1: group1, group2: group2 };
   }

   // Function to split aspect pool into two groups for 4-group mode
   function splitTraitsPoolIntoGroups(traitsPool, rng) {
     var shuffledPool = traitsPool.slice();
     shuffleArray(shuffledPool, rng);
     
     var midPoint = Math.floor(shuffledPool.length / 2);
     var group1 = shuffledPool.slice(0, midPoint).sort(function(a, b) {
      // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
      var typeOrderA = getAspectTypeOrder(a);
      var typeOrderB = getAspectTypeOrder(b);
      
      if (typeOrderA !== typeOrderB) {
        return typeOrderA - typeOrderB; // Sort by aspect type first
      }
      
      // Traits don't use numbered suffixes, use alphabetical sorting within same type
      return a.localeCompare(b);
    });
     var group2 = shuffledPool.slice(midPoint).sort(function(a, b) {
      // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
      var typeOrderA = getAspectTypeOrder(a);
      var typeOrderB = getAspectTypeOrder(b);
      
      if (typeOrderA !== typeOrderB) {
        return typeOrderA - typeOrderB; // Sort by aspect type first
      }
      
      // Traits don't use numbered suffixes, use alphabetical sorting within same type
      return a.localeCompare(b);
    });
     
     return { group1: group1, group2: group2 };
   }

   // Function to split aspect pool into three groups for 6-group mode
   function splitTraitsPoolIntoThreeGroups(traitsPool, rng) {
     var shuffledPool = traitsPool.slice();
     shuffleArray(shuffledPool, rng);
     
     var groupSize = Math.floor(shuffledPool.length / 3);
     var remainder = shuffledPool.length % 3;
     
     // Distribute extra items across first groups
     var group1Size = groupSize + (remainder > 0 ? 1 : 0);
     var group2Size = groupSize + (remainder > 1 ? 1 : 0);
     var group3Size = groupSize;
     
     var group1 = shuffledPool.slice(0, group1Size).sort(function(a, b) {
       // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
       var typeOrderA = getAspectTypeOrder(a);
       var typeOrderB = getAspectTypeOrder(b);
       
       if (typeOrderA !== typeOrderB) {
         return typeOrderA - typeOrderB; // Sort by aspect type first
       }
       
       // Traits don't use numbered suffixes, use alphabetical sorting within same type
       return a.localeCompare(b);
     });
     
     var group2 = shuffledPool.slice(group1Size, group1Size + group2Size).sort(function(a, b) {
       // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
       var typeOrderA = getAspectTypeOrder(a);
       var typeOrderB = getAspectTypeOrder(b);
       
       if (typeOrderA !== typeOrderB) {
         return typeOrderA - typeOrderB; // Sort by aspect type first
       }
       
       // Traits don't use numbered suffixes, use alphabetical sorting within same type
       return a.localeCompare(b);
     });
     
     var group3 = shuffledPool.slice(group1Size + group2Size).sort(function(a, b) {
       // First, sort by aspect type order (Aggression, Justice, Leadership, Protection, Pool)
       var typeOrderA = getAspectTypeOrder(a);
       var typeOrderB = getAspectTypeOrder(b);
       
       if (typeOrderA !== typeOrderB) {
         return typeOrderA - typeOrderB; // Sort by aspect type first
       }
       
       // Traits don't use numbered suffixes, use alphabetical sorting within same type
       return a.localeCompare(b);
     });
     
     return { group1: group1, group2: group2, group3: group3 };
   }

   // Function to split hero pool into three groups for 6-group mode
   function splitHeroPoolIntoThreeGroups(heroPool, rng) {
     var shuffledPool = heroPool.slice();
     shuffleArray(shuffledPool, rng);
     
     var groupSize = Math.floor(shuffledPool.length / 3);
     var remainder = shuffledPool.length % 3;
     
     var group1 = shuffledPool.slice(0, groupSize + (remainder > 0 ? 1 : 0)).sort(function(a, b) {
       // Alphabetical sorting for heroes
       return a.localeCompare(b);
     });
     
     var group2Start = groupSize + (remainder > 0 ? 1 : 0);
     var group2 = shuffledPool.slice(group2Start, group2Start + groupSize + (remainder > 1 ? 1 : 0)).sort(function(a, b) {
       // Alphabetical sorting for heroes
       return a.localeCompare(b);
     });
     
     var group3Start = group2Start + groupSize + (remainder > 1 ? 1 : 0);
     var group3 = shuffledPool.slice(group3Start).sort(function(a, b) {
       // Alphabetical sorting for heroes
       return a.localeCompare(b);
     });
     
     return { group1: group1, group2: group2, group3: group3 };
   }

   // Function to renumber aspects in descending order within each type
   // Function no longer needed - traits don't use numbered suffixes
   // function renumberAspectPriorityForDisplay(aspectList) { ... }

   // Function to assign aspect to Spider-Woman
   function assignSpiderWomanAspect(rng) {
     var aspects = ['Aggression', 'Justice', 'Leadership', 'Protection', 'Pool'];
     var weights = [2, 2, 2, 2, 1]; // Aggression=2, Justice=2, Leadership=2, Protection=2, Pool=1
     
     var totalWeight = weights.reduce(function(sum, weight) {
       return sum + weight;
     }, 0);
     var random = rng.next() * totalWeight;
     var cumulativeWeight = 0;
     
     for (var i = 0; i < aspects.length; i++) {
       cumulativeWeight += weights[i];
       if (random <= cumulativeWeight) {
         return aspects[i];
       }
     }
     
     return aspects[0]; // Fallback
   }

   // Banned heroes
   var bannedHeroes = ['Angel', 'Wasp', 'Ant-Man', 'Ironheart', 'SP//dr'];

  // Banned traits
  var bannedTraits = [];

   // Available traits
   var traitList = [
     "(Spider-Man - Peter Parker) Hero: Avenger - AE: Genius",
     "(Captain Marvel) Hero: Avenger, Soldier - AE: SHIELD, Soldier",
     "(She-Hulk) Hero: Avenger, Gamma - AE: Attorney, Gamma",
     "(Iron Man) Hero: Avenger - AE: Genius",
     "(Black Panther - T'Challa) Hero: Avenger, Wakanda - AE: King, Wakanda",
     "(Captain America) Hero: Avenger, Soldier - AE: SHIELD, Soldier",
     "(Hawkeye) Hero: Avenger - AE: SHIELD",
     "(Spider-Woman) Hero: Avenger, Spy - AE: SHIELD, Spy",
     "(Ms. Marvel) Hero: Champion, Inhuman - AE: Inhuman",
     "(Thor) Hero: Asgard, Avenger - AE: Asgard",
     "(Black Widow) Hero: Avenger, Spy - AE: SHIELD, Spy",
     "(Doctor Strange) Hero: Avenger, Mystic - AE: Mystic",
     "(Hulk) Hero: Avenger, Gamma - AE: Genius, Scientist",
     "(Quicksilver) Hero: Avenger - AE: Civilian",
     "(Scarlet Witch) Hero: Avenger, Mystic - AE: Mystic",
     "(Groot) Hero: Guardian - AE: Outlaw",
     "(Rocket Raccoon) Hero: Guardian - AE: Genius, Outlaw",
     "(Star-Lord) Hero: Guardian - AE: Outlaw",
     "(Gamora) Hero: Guardian - AE: Outlaw",
     "(Drax) Hero: Guardian - AE: Outlaw",
     "(Venom) Hero: Guardian, Space Knight - AE: Soldier",
     "(Spectrum) Hero: Aerial, Avenger - AE: Civilian",
     "(Adam Warlock) Hero: Guardian, Mystic - AE: Mystic",
     "(Nebula) Hero: Guardian - AE: Outlaw",
     "(War Machine) Hero: Avenger, Soldier - AE: SHIELD, Soldier",
     "(Valkyrie) Hero: Asgard, Avenger - AE: Asgard",
     "(Vision) Hero: Android, Avenger - AE: Android",
     "(Ghost-Spider) Hero: Web-Warrior - AE: Civilian",
     "(Spider-Man - Miles Morales) Hero: Champion, Web-Warrior - AE: Civilian",
     "(Nova) Hero: Champion - AE: Civilian",
     "(Spider-Ham) Hero: Cartoon, Web-Warrior - AE: Cartoon, Civilian",
     "(Colossus) Hero: X-Men - AE: Mutant",
     "(Shadowcat) Hero: X-Men - AE: Mutant",
     "(Cyclops) Hero: X-Men - AE: Mutant",
     "(Phoenix) Hero: Psionic, X-Men - AE: Mutant, Psionic",
     "(Wolverine) Hero: X-Men - AE: Mutant",
     "(Storm) Hero: X-Men - AE: Mutant",
     "(Gambit) Hero: Thief, X-Men - AE: Mutant, Thief",
     "(Rogue) Hero: X-Men - AE: Mutant",
     "(Cable) Hero: Soldier, X-Force - AE: Mutant, Soldier",
     "(Domino) Hero: Posse, X-Force - AE: Mutant",
     "(Psylocke) Hero: Psionic, X-Force - AE: Mutant, Psionic",
     "(X-23) Hero: X-Force - AE: Mutant",
     "(Deadpool) Hero: Deadpool Corps, X-Force - AE: Mercenary, Mutant",
     "(Bishop) Hero: Temporal, X-Men - AE: Mutant, Temporal",
     "(Magik) Hero: Mystic, X-Men - AE: Mutant, Mystic",
     "(Iceman) Hero: Ice, X-Men - AE: Mutant",
     "(Jubilee) Hero: X-Men - AE: Mutant",
     "(Nightcrawler) Hero: X-Men - AE: Mutant",
     "(Magneto) Hero: X-Men - AE: Mutant",
     "(Maria Hill) Hero: SHIELD, Spy - AE: SHIELD, Spy",
     "(Nick Fury) Hero: SHIELD, Soldier, Spy - AE: SHIELD, Soldier, Spy",
     "(Black Panther - Shuri) Hero: Wakanda - AE: Genius, Wakanda",
     "(Silk) Hero: Web-Warrior - AE: Genius",
     "(Falcon) Hero: Aerial, Avenger - AE: SHIELD",
     "(Winter Soldier) Hero: SHIELD, Soldier - AE: SHIELD, Soldier"
   ];

   // Bot draft order
   var draftOrder = [
     'Spider-Ham', 'Cable', 'Cyclops', 'Storm', 'Magik', 'Psylocke', 'Maria Hill',
     'Bishop', 'Spider-Man (Peter Parker)', 'Doctor Strange', 'Spider-Man (Miles Morales)',
     'Captain Marvel', 'Scarlet Witch', 'X-23', 'Deadpool',
     'Black Panther (Shuri)', 'Magneto', 'Ironheart', 'Vision', 'Captain America', 
     'Domino', 'Angel', 'Shadowcat', 'Nova',
     'Nick Fury', 'Iron Man', 'Silk', 'Spider-Woman', 'SP//dr',
     'Phoenix', 'Wolverine', 'Venom', 'Rogue', "Black Panther (T'Challa)",
     'Ant-Man', 'Star-Lord', 'Spectrum', 'Colossus', 'Jubilee', 
     'Gambit', 'Iceman', 'Rocket',
     'Falcon', 'Winter Soldier',
     'Adam Warlock', 'Gamora', 'Ghost-Spider', 'Drax', 'Black Widow', 'Nightcrawler', 'Wasp',
     'Ms Marvel', 'Nebula', 'She-Hulk', 'Thor', 'War Machine', 'Quicksilver',
     'Hawkeye', 'Groot', 'Valkyrie', 'Hulk'
   ];

   // Check if hero is banned
   function isHeroBanned(heroName) {
     if (bannedHeroes.includes(heroName)) return true;
     var heroBaseName = heroName.split(' - ')[0];
     for (var i = 0; i < bannedHeroes.length; i++) {
       var bannedHero = bannedHeroes[i];
       var bannedBaseName = bannedHero.split(' - ')[0];
       if (heroBaseName === bannedBaseName) return true;
     }
     return false;
   }

   // Check if trait is banned
   function isTraitBanned(traitName) {
     if (bannedTraits.includes(traitName)) return true;
     // Extract character name from trait for comparison
     var characterMatch = traitName.match(/^\(([^)]+)\)/);
     if (characterMatch) {
       var characterName = characterMatch[1];
       for (var i = 0; i < bannedTraits.length; i++) {
         var bannedTrait = bannedTraits[i];
         var bannedCharacterMatch = bannedTrait.match(/^\(([^)]+)\)/);
         if (bannedCharacterMatch && characterName === bannedCharacterMatch[1]) return true;
       }
     }
     return false;
   }

   var filteredDraftOrder = draftOrder.filter(function(hero) {
     return !isHeroBanned(hero);
   });
   var marvelHeroes = filteredDraftOrder.slice().sort();

   // Team name pools
   var teamNamePools = {
     0: ['Aaron Davis', 'Abigail Brand', 'Adrian Toomes', 'Amora', 'Arnim Zola'],
     1: ['Betty Ross', 'Bullseye', 'Bruno Carrelli', 'Baron Mordo', 'Beetle', 'Black Tom Cassidy', 'Black Swan', 'Boomerang', 'Betty Brant'],
     2: ['Calvin Zabo', 'Cassandra Nova', 'Curt Connors', 'Clea', 'Carl "Crusher" Creel', 'Cassie Lang', 'Colleen Wing'],
     3: ['Doctor Doom', 'Donald Pierce', 'Dormammu', 'Daken', 'Danny Rand', 'Donald Blake'],
     4: ['Edwin Jarvis', 'Elektra', 'Emil Blonsky', 'Everett Ross', 'Ebony Maw', 'Eddie Brock', 'Exodus', 'Ego the Living Planet'],
     5: ['Felicia Hardy', 'Fin Fang Foom', 'Frank Castle', 'Franklin Richards', 'Frigga', 'Foggy Nelson'],
     6: ['Gwen Stacy', 'George Stacy', 'Gorgon', 'Giganto', 'Gilgamesh', 'Grandmaster', 'Gorr'],
     7: ['Harry Osborn', 'Howard Stark', 'Hope Pym', 'Hobgoblin', 'Helmut Zemo', 'Happy Hogan', 'Howard the Duck', 'Husk', 'High Evolutionary'],
     8: ['Illyana Rasputin', 'Imperial Guard', 'Iron Fist'],
     9: ['J Jonah Jameson', 'Janet Van Dyne', 'Jessica Jones', 'Jacosta', 'Jamie Madrox', 'Jimmy Woo', 'Johnny Blaze', 'Jessica Drew'],
     10: ['Karnak', 'Kurt Wagner', 'Kitty Pryde', 'Kaluu', 'Kamala Khan', 'Kang the Conqueror', 'Kid Omega', 'Killmonger', 'Kingpin', 'Klaw'],
     11: ['Laufey', 'Leo Fitz', 'Lucia von Bardas', 'Luke Cage', 'Loki', 'Lizard', 'Lorna Dane', 'Logan']
   };

   // Random number generator
   function Random(seed) {
     if (typeof seed === 'undefined') {
       seed = Math.random();
     }
     if (typeof seed === 'string') {
       this.seed = this.stringToHash(seed);
     } else {
       this.seed = this.hash(seed.toString());
     }
   }

   Random.prototype.stringToHash = function(str) {
     if (str === '') return 0;
     var hash = 0;
     for (var i = 0; i < str.length; i++) {
       var char = str.charCodeAt(i);
       hash = ((hash << 5) - hash) + char;
       hash = hash & hash;
     }
     return Math.abs(hash);
   };

   Random.prototype.hash = function(str) {
     var hash = 0;
     for (var i = 0; i < str.length; i++) {
       var char = str.charCodeAt(i);
       hash = ((hash << 5) - hash) + char;
       hash = hash & hash;
     }
     return Math.abs(hash);
   };

   Random.prototype.next = function() {
     this.seed = (1664525 * this.seed + 1013904223) >>> 0;
     return this.seed / 0xFFFFFFFF;
   };

   function shuffleArray(array, rng) {
     for (var i = array.length - 1; i > 0; i--) {
       var j = Math.floor(rng.next() * (i + 1));
       var temp = array[i];
       array[i] = array[j];
       array[j] = temp;
     }
   }

   // Initialize display
   try {
     // Check if elements exist and populate them
     var allHeroesElement = document.getElementById('allHeroes');
     var allTraitsElement = document.getElementById('allTraits');
     var bannedHeroesElement = document.getElementById('bannedHeroes');
    var bannedTraitsElement = document.getElementById('bannedTraits');
     
     if (allHeroesElement && marvelHeroes && marvelHeroes.length > 0) {
       allHeroesElement.innerHTML = marvelHeroes.map(function(hero) {
         return '<div class="hero-card">' + hero + '</div>';
       }).join('');
     }
     
     // Initialize allTraits with the complete trait list for display
     allTraits = traitList.slice();
     
     if (allTraitsElement && allTraits && allTraits.length > 0) {
       allTraitsElement.innerHTML = allTraits.map(function(trait) {
         var traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
         // Parse trait into 3 components for multi-line display
         var traitParts = parseTraitForDisplay(trait);
         var multiLineContent = 
           '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
           '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
           '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
         return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
       }).join('');
     }
     
     if (bannedHeroesElement && bannedHeroes && bannedHeroes.length > 0) {
       bannedHeroesElement.innerHTML = bannedHeroes.map(function(hero) {
         return '<div class="hero-card">' + hero + '</div>';
       }).join('');
     }
   } catch (error) {
     // Silent error handling - preserve initialization flow
   }

   // Update max extras and default value based on draft pool groups
   function updateMaxExtras() {
     return safeExecute(function() {
       var numberOfTeams = parseInt(document.getElementById('teamsInput').value) || 10;
       var draftPoolGroups = document.getElementById('draftPoolGroups').value;
       var extrasInput = document.getElementById('extrasInput');
       
       var maxExtras, defaultExtras;
       if (draftPoolGroups === '4') {
         // For 4-group mode: total heroes needed = 2 * (teams + extras per group)
         maxExtras = Math.floor((marvelHeroes.length / 2) - numberOfTeams);
         defaultExtras = 3;
       } else if (draftPoolGroups === '6') {
         // For 6-group mode: total heroes needed = 3 * (teams + extras per group)
         maxExtras = Math.floor((marvelHeroes.length / 3) - numberOfTeams);
         defaultExtras = 2;
       }
       
       document.getElementById('maxExtras').textContent = maxExtras;
       
       // Update default value if current value is the old default or if switching modes
       var currentValue = parseInt(extrasInput.value) || 0;
       
       if (currentValue === 6 || currentValue === 3 || currentValue === 0) {
         extrasInput.value = defaultExtras;
       }
       
       // Ensure current value doesn't exceed new maximum
       if (currentValue > maxExtras) {
         extrasInput.value = maxExtras;
       }
       
       extrasInput.setAttribute('max', maxExtras);
      
      // Update round preferences text based on draft mode
      var roundPreferencesText = document.getElementById('roundPreferencesText');
      if (roundPreferencesText) {
        if (draftPoolGroups === '6') {
          roundPreferencesText.textContent = 'Chance to ignore round preferences (Hero R1&3&5, Traits R2&4&6)';
        } else {
          roundPreferencesText.textContent = 'Chance to ignore round preferences (Hero R1&3, Traits R2&4)';
        }
      }
       
       // Update UI text based on draft mode
       // Add 6-group mode support
       if (draftPoolGroups === '6') {
         document.getElementById('draftDescription').textContent = 'Each kouple drafts 3 heroes and 3 traits over 6 rounds';
         document.getElementById('draftRulesText').innerHTML = 
           '<strong>Draft Rules:</strong> 6 rounds total. Each kouple picks 3 heroes and 3 traits. You can choose heroes or traits freely within constraints.<br>' +
           '<strong>Group Restrictions (6-group mode):</strong> Each kouple can only draft one hero from each hero group (3 groups) AND one traits from each traits group (3 groups).<br>' +
           '<strong>Bot Strategy:</strong> Three-stage system - 1) Check round preferences, 2) Check for surprise picks (random), 3) Use strategic selection.<br>' +
           '<strong>Round Preferences:</strong> Bots prefer Hero in R1&R3&R5, Traits in R2&R4&R6. "Bot Ignore Round Preferences" slider controls chance to draft opposite type.<br>';
       } else if (draftPoolGroups === '4') {
         document.getElementById('draftDescription').textContent = 'Each kouple drafts 2 heroes and 2 traits over 4 rounds';
         document.getElementById('draftRulesText').innerHTML = 
           '<strong>Draft Rules:</strong> 4 rounds total. Each kouple picks 2 heroes and 2 traits. You can choose heroes or traits freely within constraints.<br>' +
           '<strong>Group Restrictions (4-group mode):</strong> Each kouple can only draft one hero from each hero group AND one traits from each traits group. Second picks must be from opposite groups.<br>' +
           '<strong>Bot Strategy:</strong> Three-stage system - 1) Check round preferences, 2) Check for surprise picks (random), 3) Use strategic selection.<br>' +
           '<strong>Round Preferences:</strong> Bots prefer Hero in R1&R3, Traits in R2&R4. "Bot Ignore Round Preferences" slider controls chance to draft opposite type.<br>';
       }
       
       var currentValue = parseInt(extrasInput.value) || 6;
       if (currentValue > maxExtras) {
         extrasInput.value = maxExtras;
       }
       
       // Update bot strategy text to reflect new draft mode
       updateBotSettings();
     }, null, [], 'updateMaxExtras');
   }
   
   updateMaxExtras();
   document.getElementById('teamsInput').addEventListener('input', updateMaxExtras);
   document.getElementById('draftPoolGroups').addEventListener('change', updateMaxExtras);

   // Generate pool button event listener
   document.getElementById('goButton').addEventListener('click', function() {
   try {
     var seedInput = document.getElementById('seedInput').value;
     var rng = new Random(seedInput || Math.random());
     
     var numberOfTeams = parseInt(document.getElementById('teamsInput').value);
     var numberOfExtras = parseInt(document.getElementById('extrasInput').value) || 6;
     var draftPoolGroups = document.getElementById('draftPoolGroups').value;
     
     var numberOfHeroes;
     if (draftPoolGroups === '4') {
       // For 4-group mode: each group has (teams + extras), total = 2 * (teams + extras)
       numberOfHeroes = 2 * (numberOfTeams + numberOfExtras);
     } else if (draftPoolGroups === '6') {
       // For 6-group mode: each group has (teams + extras), total = 3 * (teams + extras)
       numberOfHeroes = 3 * (numberOfTeams + numberOfExtras);
     } else {
       // Fallback to 4-group mode behavior
       numberOfHeroes = 2 * (numberOfTeams + numberOfExtras);
     }

     if (numberOfHeroes > marvelHeroes.length) {
       alert('Pool size too large! Maximum extras possible: ' + (marvelHeroes.length - (2 * numberOfTeams)));
       return;
     }

     // Generate hero pool
     var heroesPool = marvelHeroes.slice();
     shuffleArray(heroesPool, rng);

     var selectedHeroes = heroesPool.slice(0, numberOfHeroes);
     var excludedHeroes = heroesPool.slice(numberOfHeroes).sort();
     
     // Handle Spider-Woman aspect assignment
     var spiderWomanIndex = selectedHeroes.findIndex(function(hero) {
       return hero === 'Spider-Woman';
     });
     if (spiderWomanIndex !== -1) {
       var assignedAspect = assignSpiderWomanAspect(rng);
       selectedHeroes[spiderWomanIndex] = 'Spider-Woman - ' + assignedAspect;
     }
     
     selectedHeroes.sort();
     
     // Check for 4-group mode and split heroes
      if (draftPoolGroups === '4') {
       var heroGroups = splitHeroPoolIntoGroups(selectedHeroes, rng);
       heroGroup1 = heroGroups.group1;
       heroGroup2 = heroGroups.group2;
       heroGroup3 = [];
     } else if (draftPoolGroups === '6') {
       var heroGroups = splitHeroPoolIntoThreeGroups(selectedHeroes, rng);
       heroGroup1 = heroGroups.group1;
       heroGroup2 = heroGroups.group2;
       heroGroup3 = heroGroups.group3;
     } else {
       // Fallback to 4-group mode behavior
       var heroGroups = splitHeroPoolIntoGroups(selectedHeroes, rng);
       heroGroup1 = heroGroups.group1;
       heroGroup2 = heroGroups.group2;
       heroGroup3 = [];
     }

    // Generate traits pool
    // Generate traits pool using random selection from traitList
    var traitsPool = [];
    var filteredTraits = traitList.filter(function(trait) { return !isTraitBanned(trait); });
    var shuffledTraits = filteredTraits.slice(); // Copy the filtered trait list
    shuffleArray(shuffledTraits, rng);
    
    // Generate all traits using random selection from shuffled list
    for (var i = 0; i < numberOfHeroes; i++) {
      var selectedTrait = shuffledTraits[i % shuffledTraits.length];
      traitsPool.push(selectedTrait);
    }
    
    // Use traits directly without numbering since each trait is unique
    allTraits = traitsPool.slice();
     
     // Check for 4-group mode and split aspects
      // Add 6-group mode support for 3 aspect groups
     if (draftPoolGroups === '6') {
       var traitsGroups = splitTraitsPoolIntoThreeGroups(traitsPool, rng);
       traitsGroup1 = traitsGroups.group1;
       traitsGroup2 = traitsGroups.group2;
       traitsGroup3 = traitsGroups.group3;
       window.traitsGroup1 = traitsGroup1;
       window.traitsGroup2 = traitsGroup2;
       window.traitsGroup3 = traitsGroup3;
     } else if (draftPoolGroups === '4') {
       var traitsGroups = splitTraitsPoolIntoGroups(traitsPool, rng);
       traitsGroup1 = traitsGroups.group1;
       traitsGroup2 = traitsGroups.group2;
       traitsGroup3 = [];
       window.traitsGroup1 = traitsGroup1;
       window.traitsGroup2 = traitsGroup2;
       window.traitsGroup3 = traitsGroup3;
     } else {
       // Fallback to 4-group mode behavior
       var traitsGroups = splitTraitsPoolIntoGroups(traitsPool, rng);
       traitsGroup1 = traitsGroups.group1;
       traitsGroup2 = traitsGroups.group2;
       traitsGroup3 = [];
       window.traitsGroup1 = traitsGroup1;
       window.traitsGroup2 = traitsGroup2;
       window.traitsGroup3 = traitsGroup3;
     }
    
    // Calculate excluded traits after traits pool generation
    var excludedTraits = filteredTraits.filter(function(trait) {
      return !traitsPool.includes(trait);
    }).sort();
     
     // Disabled aspect priority order initialization for traits system
    initializeTraitsPriorityOrder(true, rng);

     // Update draft bot order to use the aspect-assigned Spider-Woman name
     var draftBot = filteredDraftOrder.slice();
     var spiderWomanBotIndex = draftBot.findIndex(function(hero) {
       return hero === 'Spider-Woman';
     });
     // Find Spider-Woman variant in selectedHeroes after sorting
    var spiderWomanVariantInSelected = selectedHeroes.find(function(hero) {
      return hero.startsWith('Spider-Woman - ');
    });
    
    if (spiderWomanBotIndex !== -1 && spiderWomanVariantInSelected) {
       draftBot[spiderWomanBotIndex] = spiderWomanVariantInSelected;
     }
     
    draftBot = draftBot.filter(function(hero) {
       return selectedHeroes.includes(hero);
     });

     
    // Update filteredDraftOrder to use the corrected draftBot array
    filteredDraftOrder = draftBot.slice();

    // Get custom teams
     var customTeamList = document.getElementById('teamListInput').value.trim();
     var customTeams = customTeamList ? customTeamList.split('\n').map(function(name) {
       return name.trim();
     }).filter(function(name) {
       return name.length > 0;
     }) : [];
     
     var userTeamName = customTeams.length > 0 ? customTeams[0] : '';
     var numberOfActualTeams = userTeamName ? numberOfTeams - 1 : numberOfTeams;
     
     var teams = Array.from({ length: numberOfActualTeams }, function(_, i) {
       var customIndex = i + 1;
       if (customIndex < customTeams.length) {
         return customTeams[customIndex];
       }
       
       if (teamNamePools[i]) {
         var namePool = teamNamePools[i].slice();
         var randomIndex = Math.floor(rng.next() * namePool.length);
         return namePool[randomIndex];
       } else {
         return 'Kouple ' + String.fromCharCode(65 + i);
       }
     });
     
     if (userTeamName) {
       teams.push(userTeamName);
     }
     
     shuffleArray(teams, rng);

     // Display results based on group mode
     if (draftPoolGroups === '6') {
       // Display three hero groups for 6-group mode
       document.getElementById('resultPool').innerHTML = 
         '<div class="result-section" style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 15px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Hero Group 1</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             heroGroup1.map(function(hero) {
               return '<div class="hero-card">' + hero + '</div>';
             }).join('') +
           '</div>' +
         '</div>' +
         '<div class="result-section" style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 15px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Hero Group 2</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             heroGroup2.map(function(hero) {
               return '<div class="hero-card">' + hero + '</div>';
             }).join('') +
           '</div>' +
         '</div>' +
         '<div class="result-section" style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 15px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Hero Group 3</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             heroGroup3.map(function(hero) {
               return '<div class="hero-card">' + hero + '</div>';
             }).join('') +
           '</div>' +
         '</div>';
     } else if (draftPoolGroups === '4') {
       // Display separate hero groups with proper section formatting
       document.getElementById('resultPool').innerHTML = 
         '<div class="result-section" style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 15px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Hero Group 1</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             heroGroup1.map(function(hero) {
               return '<div class="hero-card">' + hero + '</div>';
             }).join('') +
           '</div>' +
         '</div>' +
         '<div class="result-section" style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 15px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Hero Group 2</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             heroGroup2.map(function(hero) {
               return '<div class="hero-card">' + hero + '</div>';
             }).join('') +
           '</div>' +
         '</div>';
     } else {
       // Display single hero pool
       document.getElementById('resultPool').innerHTML = selectedHeroes.map(function(hero) {
         return '<div class="hero-card">' + hero + '</div>';
       }).join('');
     }
     
     // Display aspects based on group mode
      // Add 6-group mode support for 3 aspect groups display
     if (draftPoolGroups === '6' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && traitsGroup3.length > 0) {
       // Display separate aspect groups with type summaries for 6-group mode
       document.getElementById('resultTraitsPool').innerHTML = 
         '<div class="result-section" style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Traits Group 1</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             traitsGroup1.map(function(aspect) {
               var aspectType = getAspectType(aspect);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspect);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
             }).join('') +
           '</div>' +
         '</div>' +
         '<div class="result-section" style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Traits Group 2</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             traitsGroup2.map(function(aspect) {
               var aspectType = getAspectType(aspect);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspect);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
             }).join('') +
           '</div>' +
         '</div>' +
         '<div class="result-section" style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Traits Group 3</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             traitsGroup3.map(function(aspect) {
               var aspectType = getAspectType(aspect);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspect);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
             }).join('') +
           '</div>' +
         '</div>';
     } else if (draftPoolGroups === '4' && traitsGroup1.length > 0 && traitsGroup2.length > 0) {
       // Display separate aspect groups with type summaries
       document.getElementById('resultTraitsPool').innerHTML = 
         '<div class="result-section" style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Traits Group 1</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             traitsGroup1.map(function(aspect) {
               var aspectType = getAspectType(aspect);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspect);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
             }).join('') +
           '</div>' +
         '</div>' +
         '<div class="result-section" style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">' +
           '<h3 style="margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: #2c2c54;">Traits Group 2</h3>' +
           '<div class="hero-grid" style="display: flex; flex-wrap: wrap; gap: 8px;">' +
             traitsGroup2.map(function(aspect) {
               var aspectType = getAspectType(aspect);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspect);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
             }).join('') +
           '</div>' +
         '</div>';
     }
     
     document.getElementById('resultDraftBot').innerHTML = draftBot.map(function(hero) {
       return '<div class="hero-card">' + hero + '</div>';
     }).join('');
     
     // Display bot aspect priority
     document.getElementById('resultDraftBotTraits').innerHTML = traitsPriorityList.map(function(aspect) {
       var aspectType = getAspectType(aspect);
       var traitStyle = '';
       // All traits use consistent blue styling
       traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
       // Parse trait into 3 components for multi-line display
      var traitParts = parseTraitForDisplay(aspect);
      var multiLineContent = 
        '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
        '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
        '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
      return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
     }).join('');
     
     document.getElementById('resultDraftOrder').innerHTML = teams.map(function(team, index) {
       return '<div class="kouple-card">' + (index + 1) + '. ' + team + '</div>';
     }).join('');
     
     document.getElementById('resultExcluded').innerHTML = excludedHeroes.map(function(hero) {
       return '<div class="hero-card">' + hero + '</div>';
     }).join('');
    
    document.getElementById('resultExcludedTraits').innerHTML = excludedTraits.map(function(trait) {
      var traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
      // Parse trait into 3 components for multi-line display
      var traitParts = parseTraitForDisplay(trait);
      var multiLineContent = 
        '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
        '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
        '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
      return '<div class="hero-card trait-card-multiline" style="' + traitStyle + '">' + multiLineContent + '</div>';
    }).join('');

     document.getElementById('results').style.display = 'block';
     document.getElementById('footerNote').style.display = 'block';
     
     document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
   } catch (error) {
      alert('Error generating draft pool: ' + error.message);
   }
   });

   // Helper function to get highest available Leadership aspect
   function getHighestAvailableLeadership() {
     var availableLeadership = allTraits.filter(function(aspect) {
       var aspectType = getAspectType(aspect);
       return aspectType === 'Leadership' && !draftedTraits.includes(aspect);
     });
     
     if (availableLeadership.length === 0) return null;
     
     // Sort alphabetically and return the first available trait
     availableLeadership.sort();
     
     return availableLeadership[0];
   }

   // Helper function to get highest available aspect of specified type
   function getHighestAvailableAspect(aspectType) {
     var availableInstances = allTraits.filter(function(aspect) {
       var currentType = getAspectType(aspect);
       return currentType === aspectType && !draftedTraits.includes(aspect);
     });
     
     if (availableInstances.length === 0) return null;
     
     availableInstances.sort();
     
     return availableInstances[0];
   }

   // Get highest available aspect of specified type within specific group
   function getHighestAvailableAspectInGroup(aspectType, groupNumber) {
     // Get the appropriate group array
     var groupAspects = groupNumber === 1 ? traitsGroup1 : traitsGroup2;
     
     // Filter to only aspects of the specified type within this group that aren't drafted
     var availableInstances = groupAspects.filter(function(aspect) {
       var currentType = getAspectType(aspect);
       return currentType === aspectType && !draftedTraits.includes(aspect);
     });
     
     if (availableInstances.length === 0) {
       return null;
     }
     
     // Sort by number in descending order and return the highest
     availableInstances.sort();
     
     return availableInstances[0];
   }

   // Get selectable aspects in group (highest numbered of each type only)
   function getSelectableAspectsInGroup(groupNumber) {
     // Get the appropriate group array - Add support for group 3
     var groupAspects = groupNumber === 1 ? traitsGroup1 : (groupNumber === 2 ? traitsGroup2 : traitsGroup3);
     
     // Group aspects by type
     var aspectsByType = {};
     groupAspects.forEach(function(aspect) {
       var aspectType = getAspectType(aspect);
       if (!aspectsByType[aspectType]) {
         aspectsByType[aspectType] = [];
       }
       aspectsByType[aspectType].push(aspect);
     });
     
     // Get highest numbered (non-drafted) aspect of each type
     var selectableAspects = [];
     Object.keys(aspectsByType).forEach(function(aspectType) {
       var typeAspects = aspectsByType[aspectType];
       
       // Filter out drafted aspects
       var availableTypeAspects = typeAspects.filter(function(aspect) {
         return !draftedTraits.includes(aspect);
       });
       
       if (availableTypeAspects.length > 0) {
         // Sort by number in descending order and take the highest
         availableTypeAspects.sort();
         
         selectableAspects.push(availableTypeAspects[0]);
       }
     });
     
     return selectableAspects;
   }

   function canTeamDraft(teamName, draftType) {
     var picks = teamPicks[teamName] || [];
     var heroes = picks.filter(function(pick) {
       return allHeroes.includes(pick);
     });
     var aspects = picks.filter(function(pick) {
       return allTraits.includes(pick);
     });
     
     if (draftType === 'hero') {
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       // Support 3 heroes in 6-group mode
       var maxHeroes = draftPoolGroups === '6' ? 3 : 2;
       
       if (heroes.length >= maxHeroes) {
         return false; // Already have max heroes (2 for 4-group, 3 for 6-group)
       }
       
       // Check hero group restrictions in 4-group mode
        if (draftPoolGroups === '4' && heroGroup1.length > 0 && heroGroup2.length > 0) {
         var group1Heroes = heroes.filter(function(hero) { return getHeroGroup(hero) === 1; });
         var group2Heroes = heroes.filter(function(hero) { return getHeroGroup(hero) === 2; });
         
         // If team already has a hero from both groups, they can't draft more heroes
         if (group1Heroes.length >= 1 && group2Heroes.length >= 1) {
           return false;
         }
       } else if (draftPoolGroups === '6' && heroGroup1.length > 0 && heroGroup2.length > 0 && heroGroup3.length > 0) {
         var group1Heroes = heroes.filter(function(hero) { return getHeroGroup(hero) === 1; });
         var group2Heroes = heroes.filter(function(hero) { return getHeroGroup(hero) === 2; });
         var group3Heroes = heroes.filter(function(hero) { return getHeroGroup(hero) === 3; });
         
         // Each team can only have one hero from each of the 3 groups
         if ((group1Heroes.length >= 1 && group2Heroes.length >= 1 && group3Heroes.length >= 1) ||
             group1Heroes.length >= 2 || group2Heroes.length >= 2 || group3Heroes.length >= 2) {
           return false;
         }
       }
       
       return true;
     } else if (draftType === 'aspect') {
       // Support 3 aspects maximum in 6-group mode
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       var maxAspects = draftPoolGroups === '6' ? 3 : 2;
       
       if (aspects.length >= maxAspects) {
         return false; // Already have max aspects (2 for most modes, 3 for 6-group mode)
       }
       
       // Check aspect group restrictions in 4-group mode
        // Add 6-group mode support for 3 aspect groups
       if (draftPoolGroups === '6' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && traitsGroup3.length > 0) {
         var group1Aspects = aspects.filter(function(aspect) { return getAspectGroup(aspect) === 1; });
         var group2Aspects = aspects.filter(function(aspect) { return getAspectGroup(aspect) === 2; });
         var group3Aspects = aspects.filter(function(aspect) { return getAspectGroup(aspect) === 3; });
         
         // If team already has an aspect from all 3 groups, they can't draft more aspects
         if (group1Aspects.length >= 1 && group2Aspects.length >= 1 && group3Aspects.length >= 1) {
           return false;
         }
       } else if (draftPoolGroups === '4' && traitsGroup1.length > 0 && traitsGroup2.length > 0) {
         var group1Aspects = aspects.filter(function(aspect) { return getAspectGroup(aspect) === 1; });
         var group2Aspects = aspects.filter(function(aspect) { return getAspectGroup(aspect) === 2; });
         
         // If team already has an aspect from both groups, they can't draft more aspects
         if (group1Aspects.length >= 1 && group2Aspects.length >= 1) {
           return false;
         }
       }
       
       return true;
     }
     return false;
   }
   
   // Check if team can draft from specific hero group
   function canTeamDraftFromGroup(teamName, groupNumber) {
     var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
     if (draftPoolGroups === '4' && (heroGroup1.length === 0 || heroGroup2.length === 0)) {
       return true; // No restrictions if groups aren't set up
     } else if (draftPoolGroups === '6' && (heroGroup1.length === 0 || heroGroup2.length === 0 || heroGroup3.length === 0)) {
       return true; // No restrictions if groups aren't set up
     } else if (draftPoolGroups !== '4' && draftPoolGroups !== '6') {
       return true; // No restrictions if not 4-group or 6-group mode
     }
     
     var picks = teamPicks[teamName] || [];
     var heroes = picks.filter(function(pick) {
       return allHeroes.includes(pick);
     });
     
     var groupHeroes = heroes.filter(function(hero) { 
       return getHeroGroup(hero) === groupNumber; 
     });
     
     return groupHeroes.length === 0; // Can draft if no heroes from this group yet
   }

   // Check if team can draft from specific aspect group
   function canTeamDraftFromAspectGroup(teamName, groupNumber) {
     var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
     // Add 6-group mode support
     if (draftPoolGroups === '6') {
       if (traitsGroup1.length === 0 || traitsGroup2.length === 0 || traitsGroup3.length === 0) {
         return true; // No restrictions if groups aren't set up
       }
     } else if (draftPoolGroups !== '4' || traitsGroup1.length === 0 || traitsGroup2.length === 0) {
       return true; // No restrictions if not 4-group mode or if groups aren't set up
     }
     
     var picks = teamPicks[teamName] || [];
     var aspects = picks.filter(function(pick) {
       return allTraits.includes(pick);
     });
     
     var groupAspects = aspects.filter(function(aspect) { 
       return getAspectGroup(aspect) === groupNumber; 
     });
     
     return groupAspects.length === 0; // Can draft if no aspects from this group yet
   }
   
   function getConstraintMessage(teamName) {
     var picks = teamPicks[teamName] || [];
     var heroes = picks.filter(function(pick) {
       return allHeroes.includes(pick);
     });
     var aspects = picks.filter(function(pick) {
       return allTraits.includes(pick);
     });
     
     // Dynamic hero limits based on draft mode
     var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
     // Support 3 heroes and 3 aspects in 6-group mode
     var maxHeroes = draftPoolGroups === '6' ? 3 : 2;
     var maxAspects = draftPoolGroups === '6' ? 3 : 2;
     var heroesLeft = maxHeroes - heroes.length;
     var aspectsLeft = maxAspects - aspects.length;
     var heroGroupInfo = '';
     var aspectGroupInfo = '';
     
     if (draftPoolGroups === '6' && heroGroup1.length > 0 && heroGroup2.length > 0 && heroGroup3.length > 0 && heroesLeft > 0) {
       var heroGroup1Available = canTeamDraftFromGroup(teamName, 1);
       var heroGroup2Available = canTeamDraftFromGroup(teamName, 2);
       var heroGroup3Available = canTeamDraftFromGroup(teamName, 3);
       
       var availableGroups = [];
       if (heroGroup1Available) availableGroups.push('1');
       if (heroGroup2Available) availableGroups.push('2');
       if (heroGroup3Available) availableGroups.push('3');
       
       if (availableGroups.length === 0) {
         heroGroupInfo = ' - no groups available';
       } else if (availableGroups.length === 3) {
         heroGroupInfo = ' from Groups ' + availableGroups.join(',');
       } else {
         heroGroupInfo = ' from Groups ' + availableGroups.join(',');
       }
     } else if (draftPoolGroups === '4' && heroGroup1.length > 0 && heroGroup2.length > 0 && heroesLeft > 0) {
       var heroGroup1Available = canTeamDraftFromGroup(teamName, 1);
       var heroGroup2Available = canTeamDraftFromGroup(teamName, 2);
       
       var availableGroups = [];
       if (heroGroup1Available) availableGroups.push('1');
       if (heroGroup2Available) availableGroups.push('2');
       
       if (availableGroups.length === 0) {
         heroGroupInfo = ' - no groups available';
       } else {
         heroGroupInfo = ' from Groups ' + availableGroups.join(',');
       }
     }
     
     // Add aspect group restriction info
     // Add 6-group mode support for 3 aspect groups
     if (draftPoolGroups === '6' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && traitsGroup3.length > 0 && aspectsLeft > 0) {
       var traitsGroup1Available = canTeamDraftFromAspectGroup(teamName, 1);
       var traitsGroup2Available = canTeamDraftFromAspectGroup(teamName, 2);
       var traitsGroup3Available = canTeamDraftFromAspectGroup(teamName, 3);
       
       var availableAspectGroups = [];
       if (traitsGroup1Available) availableAspectGroups.push('1');
       if (traitsGroup2Available) availableAspectGroups.push('2');
       if (traitsGroup3Available) availableAspectGroups.push('3');
       
       if (availableAspectGroups.length === 0) {
         aspectGroupInfo = ' - no groups available';
       } else {
         aspectGroupInfo = ' from Groups ' + availableAspectGroups.join(',');
       }
     } else if (draftPoolGroups === '4' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && aspectsLeft > 0) {
       var traitsGroup1Available = canTeamDraftFromAspectGroup(teamName, 1);
       var traitsGroup2Available = canTeamDraftFromAspectGroup(teamName, 2);
       
       var availableAspectGroups = [];
       if (traitsGroup1Available) availableAspectGroups.push('1');
       if (traitsGroup2Available) availableAspectGroups.push('2');
       
       if (availableAspectGroups.length === 0) {
         aspectGroupInfo = ' - no groups available';
       } else {
         aspectGroupInfo = ' from Groups ' + availableAspectGroups.join(',');
       }
     }
     
     if (heroesLeft === 0) {
       return "You must pick a trait (no heroes remaining)" + aspectGroupInfo;
     } else if (aspectsLeft === 0) {
       return "You must pick a hero (no traits remaining)" + heroGroupInfo;
     } else {
       return "You can pick either a hero (" + heroesLeft + " left" + heroGroupInfo + ") or trait (" + aspectsLeft + " left" + aspectGroupInfo + ")";
     }
   }

   // Export function
   function exportDraftPool() {
     return safeExecute(function() {
       var heroCards = document.getElementById('resultPool').children;
       var aspectCards = document.getElementById('resultTraitsPool').querySelectorAll('.hero-card');
       var teamCards = document.getElementById('resultDraftOrder').children;
       var excludedCards = document.getElementById('resultExcluded').children;
       var excludedTraitsCards = document.getElementById('resultExcludedTraits').children;
       var draftBotCards = document.getElementById('resultDraftBot').children;
       var draftBotAspectCards = document.getElementById('resultDraftBotTraits').children;
       
       if (heroCards.length === 0) {
         alert('Please generate a draft pool first!');
         return;
       }
       
       var numberOfTeams = document.getElementById('teamsInput').value;
       var numberOfExtras = document.getElementById('extrasInput').value;
       var seedUsed = document.getElementById('seedInput').value || 'Random';
       var customTeamList = document.getElementById('teamListInput').value.trim();
       var customTeams = customTeamList ? customTeamList.split('\n').map(function(name) {
         return name.trim();
       }).filter(function(name) {
         return name.length > 0;
       }) : [];
       var userTeam = customTeams.length > 0 ? customTeams[0] : 'None';
       var draftPoolGroups = document.getElementById('draftPoolGroups').value;
        
       var exportText = '';
       exportText += '='.repeat(50) + '\n';
       exportText += '    MODOK LEAGUE SEASON 4.5 - DRAFT POOL\n';
       exportText += '='.repeat(50) + '\n';
       exportText += 'Generated: ' + new Date().toLocaleString() + '\n';
       exportText += 'Version: ' + TOOL_VERSION + '\n';
       exportText += 'Kouples: ' + numberOfTeams + '\n';
       exportText += 'Extras: ' + numberOfExtras + '\n';
       exportText += 'Seed: ' + seedUsed + '\n';
       exportText += 'Bot Ignore Round Preferences: ' + botRandomnessPercentage + '%\n';
       exportText += 'Bot Surprise Pick: ' + botSurprisePercentage + '%\n';
        exportText += 'User Kouple: ' + userTeam + '\n';
       if (customTeamList) {
         exportText += 'Custom Kouples Used: Yes\n';
       }
       exportText += '\n';
       
       // Fix hero pool export for 4-group mode
       if (draftPoolGroups === '6' && heroGroup1.length > 0 && heroGroup2.length > 0 && heroGroup3.length > 0) {
         var totalHeroes = heroGroup1.length + heroGroup2.length + heroGroup3.length;
         exportText += 'HERO POOL (' + totalHeroes + ' heroes)\n';
         exportText += '-'.repeat(30) + '\n';
         exportText += 'Hero Group 1\n';
         for (var i = 0; i < heroGroup1.length; i++) {
           exportText += 'G1 ' + heroGroup1[i] + '\n';
         }
         exportText += '\n';
         exportText += 'Hero Group 2\n';
         for (var i = 0; i < heroGroup2.length; i++) {
           exportText += 'G2 ' + heroGroup2[i] + '\n';
         }
         exportText += '\n';
         exportText += 'Hero Group 3\n';
         for (var i = 0; i < heroGroup3.length; i++) {
           exportText += 'G3 ' + heroGroup3[i] + '\n';
         }
       } else if (draftPoolGroups === '4' && heroGroup1.length > 0 && heroGroup2.length > 0) {
         var totalHeroes = heroGroup1.length + heroGroup2.length;
         exportText += 'HERO POOL (' + totalHeroes + ' heroes)\n';
         exportText += '-'.repeat(30) + '\n';
         exportText += 'Hero Group 1\n';
         for (var i = 0; i < heroGroup1.length; i++) {
           exportText += 'G1 ' + heroGroup1[i] + '\n';
         }
         exportText += '\n';
         exportText += 'Hero Group 2\n';
         for (var i = 0; i < heroGroup2.length; i++) {
           exportText += 'G2 ' + heroGroup2[i] + '\n';
         }
       }
       exportText += '\n';
       
       // Fix aspect pool export for 4-group mode
       // Add 6-group mode
       if (draftPoolGroups === '6' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && traitsGroup3.length > 0) {
         var totalTraits = traitsGroup1.length + traitsGroup2.length + traitsGroup3.length;
         exportText += 'TRAITS POOL (' + totalTraits + ' traits)\n';
         exportText += '-'.repeat(30) + '\n';
         
         // Traits Group 1
         exportText += 'Traits Group 1 (' + traitsGroup1.length + ' traits)\n';
         for (var i = 0; i < traitsGroup1.length; i++) {
           exportText += 'G4 ' + traitsGroup1[i] + '\n';
         }
         exportText += '\n';
         
         // Traits Group 2
         exportText += 'Traits Group 2 (' + traitsGroup2.length + ' traits)\n';
         for (var i = 0; i < traitsGroup2.length; i++) {
           exportText += 'G5 ' + traitsGroup2[i] + '\n';
         }
         exportText += '\n';
         
         // Traits Group 3
         exportText += 'Traits Group 3 (' + traitsGroup3.length + ' traits)\n';
         for (var i = 0; i < traitsGroup3.length; i++) {
           exportText += 'G6 ' + traitsGroup3[i] + '\n';
         }
       } else if (draftPoolGroups === '4' && traitsGroup1.length > 0 && traitsGroup2.length > 0) {
         var totalTraits = traitsGroup1.length + traitsGroup2.length;
         exportText += 'TRAITS POOL (' + totalTraits + ' traits)\n';
         exportText += '-'.repeat(30) + '\n';
         
         // Traits Group 1
         exportText += 'Traits Group 1 (' + traitsGroup1.length + ' traits)\n';
         for (var i = 0; i < traitsGroup1.length; i++) {
           exportText += 'G3 ' + traitsGroup1[i] + '\n';
         }
         exportText += '\n';
         
         // Traits Group 2
         exportText += 'Traits Group 2 (' + traitsGroup2.length + ' traits)\n';
         for (var i = 0; i < traitsGroup2.length; i++) {
           exportText += 'G4 ' + traitsGroup2[i] + '\n';
         }
       }
       exportText += '\n';
       
       exportText += 'KOUPLE DRAFT ORDER\n';
       exportText += '-'.repeat(30) + '\n';
       for (var i = 0; i < teamCards.length; i++) {
         var teamText = teamCards[i].textContent;
         var teamName = teamText.split('. ')[1];
         exportText += teamName + '\n';
       }
       exportText += '\n';
       
       exportText += 'DRAFT BOT PRIORITY (Heroes in Pool)\n';
       exportText += '-'.repeat(30) + '\n';
       for (var i = 0; i < draftBotCards.length; i++) {
         var heroName = draftBotCards[i].textContent;
         var heroGroup = getHeroGroup(heroName);
         var groupPrefix = heroGroup > 0 ? 'G' + heroGroup + ' ' : 'G1 ';
         exportText += groupPrefix + heroName + '\n';
       }
       exportText += '\n';
       
       exportText += 'DRAFT BOT PRIORITY (Traits)\n';
       exportText += '-'.repeat(30) + '\n';
       for (var i = 0; i < traitsPriorityList.length; i++) {
         var aspectName = traitsPriorityList[i];
         var aspectGroup = getAspectGroup(aspectName);
         // Dynamic aspect group numbering
         // Add 6-group mode support for aspect group numbering
         var aspectOffset = draftPoolGroups === '6' ? 3 : 2;
         var fallbackGroup = draftPoolGroups === '6' ? 'G4 ' : 'G3 ';
         var groupPrefix = aspectGroup > 0 ? 'G' + (aspectGroup + aspectOffset) + ' ' : fallbackGroup;
         // Extract character name for cleaner export display
         var characterMatch = aspectName.match(/^\(([^)]+)\)/);
         var displayName = characterMatch ? characterMatch[1] : aspectName;
         exportText += groupPrefix + displayName + '\n';
       }
       exportText += '\n';
       
       if (excludedCards.length > 0) {
         exportText += 'EXCLUDED HEROES (' + excludedCards.length + ' heroes)\n';
         exportText += '-'.repeat(30) + '\n';
         for (var i = 0; i < excludedCards.length; i++) {
           exportText += excludedCards[i].textContent + '\n';
         }
         exportText += '\n';
       }
       
       if (excludedTraitsCards.length > 0) {
         exportText += 'EXCLUDED TRAITS (' + excludedTraitsCards.length + ' traits)\n';
         exportText += '-'.repeat(30) + '\n';
         for (var i = 0; i < excludedTraitsCards.length; i++) {
           // Extract text content from the multi-line trait display
           var traitCard = excludedTraitsCards[i];
           var characterLine = traitCard.querySelector('.trait-character');
           if (characterLine) {
             exportText += characterLine.textContent + '\n';
           } else {
             exportText += traitCard.textContent + '\n';
           }
         }
         exportText += '\n';
       }
       
       exportText += '='.repeat(50) + '\n';
       exportText += 'Generated with Draft-o-matic ' + TOOL_VERSION + '\n';
       exportText += 'MODOK League Season 4.5\n';
       exportText += '='.repeat(50);
       
       var blob = new Blob([exportText], { type: 'text/plain' });
       var url = window.URL.createObjectURL(blob);
       var a = document.createElement('a');
       a.style.display = 'none';
       a.href = url;
       a.download = 'MODOK_S4_Draft_Pool_' + new Date().toISOString().split('T')[0] + '.txt';
       document.body.appendChild(a);
       a.click();
       window.URL.revokeObjectURL(url);
       document.body.removeChild(a);
     }, null, [], 'exportDraftPool');
   }

   // Draft simulator functions
   function startDraftSimulator() {
     return safeExecute(function() {
       // Set max rounds based on draft mode
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       if (draftPoolGroups === '6') {
         maxRounds = 6;
       } else {
         maxRounds = 4;
       }
       
       // Get custom team names to determine user team
       var customTeamList = document.getElementById('teamListInput').value.trim();
       var customTeams = customTeamList ? customTeamList.split('\n').map(function(name) {
         return name.trim();
       }).filter(function(name) {
         return name.length > 0;
       }) : [];
       var userTeamName = customTeams.length > 0 ? customTeams[0] : '';
       
       var heroCards = document.getElementById('resultPool').children;
       var aspectCards = document.getElementById('resultTraitsPool').querySelectorAll('.hero-card');
       var teamCards = document.getElementById('resultDraftOrder').children;
       
       var playerTeam = userTeamName;
       if (!playerTeam) {
         var aTeamPool = ['Aaron Davis', 'Abigail Brand', 'Adrian Toomes', 'Amora', 'Arnim Zola'];
         
         for (var i = 0; i < teamCards.length; i++) {
           var teamText = teamCards[i].textContent;
           var teamName = teamText.split('. ')[1];
           
           if (aTeamPool.includes(teamName)) {
             playerTeam = teamName;
             break;
           }
         }
         
         if (!playerTeam && teamCards.length > 0) {
           var firstTeamText = teamCards[0].textContent;
           playerTeam = firstTeamText.split('. ')[1];
         }
       }
       
       allHeroes = [];
       draftedHeroes = [];
       draftedTraits = [];
       
       // Properly handle hero data based on group mode
        var draftPoolGroups = document.getElementById('draftPoolGroups').value;
       if (draftPoolGroups === '6') {
         // For 6-group mode, combine all three hero groups
         allHeroes = heroGroup1.concat(heroGroup2).concat(heroGroup3);
       } else if (draftPoolGroups === '4') {
         // For 4-group mode, combine both hero groups
         allHeroes = heroGroup1.concat(heroGroup2);
       }
       
       // Fix Spider-Woman variant issue: replace Spider-Woman with variant if it exists
      var spiderWomanVariant = null;
      for (var i = 0; i < allHeroes.length; i++) {
        if (allHeroes[i].startsWith('Spider-Woman - ')) {
          spiderWomanVariant = allHeroes[i];
          break;
        }
      }
      if (spiderWomanVariant) {
        var spiderWomanIndex = allHeroes.indexOf('Spider-Woman');
        if (spiderWomanIndex !== -1) {
          allHeroes[spiderWomanIndex] = spiderWomanVariant;
        }
      }
      
      playerTeamName = playerTeam;
       draftOrderTeams = [];
       teamPicks = {};
       for (var i = 0; i < teamCards.length; i++) {
         var teamText = teamCards[i].textContent;
         var teamName = teamText.split('. ')[1];
         draftOrderTeams.push(teamName);
         teamPicks[teamName] = [];
       }
       
       currentTurnIndex = 0;
       currentRound = 1;
       isPlayerTurn = (draftOrderTeams[currentTurnIndex] === playerTeamName);
       
       // Initialize displays
       updateAllTeamsDisplay();
       updateAvailableItemsDisplay();
       updateBotPriorityDisplay();
       updateBotTraitsPriorityDisplay();
       
       // Update the display elements
       var playerDisplay = document.getElementById('playerTeamDisplay');
       var heroDisplay = document.getElementById('heroCountDisplay');
       var traitsDisplay = document.getElementById('traitsCountDisplay');
       var teamDisplay = document.getElementById('teamCountDisplay');
       
       if (playerDisplay) playerDisplay.textContent = playerTeam || 'Unknown Kouple';
       if (heroDisplay) heroDisplay.textContent = allHeroes.length;
       if (traitsDisplay) traitsDisplay.textContent = allTraits.length;
       if (teamDisplay) teamDisplay.textContent = teamCards.length;
       
       // Show team draft order
       var draftDisplay = document.getElementById('draftOrderDisplay');
       if (draftDisplay) {
         var draftOrderHtml = '';
         for (var i = 0; i < teamCards.length; i++) {
           var teamText = teamCards[i].textContent;
           var teamName = teamText.split('. ')[1];
           var isPlayerTeam = (teamName === playerTeam);
           
           draftOrderHtml += '<div style="padding: 8px; background: ' + (isPlayerTeam ? 'rgba(255, 107, 107, 0.2)' : 'rgba(255,255,255,0.3)') + '; border-radius: 6px; text-align: center; font-weight: ' + (isPlayerTeam ? 'bold' : 'normal') + '; border: ' + (isPlayerTeam ? '2px solid #ff6b6b' : '1px solid #ddd') + ';">' + teamText + '</div>';
         }
         draftDisplay.innerHTML = draftOrderHtml;
       }
       
       // Show draft setup
       var draftSetupElement = document.getElementById('draftSetup');
       if (draftSetupElement) {
         draftSetupElement.style.display = 'block';
         draftSetupElement.scrollIntoView({ behavior: 'smooth' });
       }
       
       // Start the draft
       updateDraftStatus();
       updateAvailableItemsDisplay();
       updateBotPriorityDisplay();
       updateBotTraitsPriorityDisplay();
       
       // If the first turn is a bot turn, start the bot picking process
       if (!isPlayerTurn) {
         setTimeout(processNextTurn, 1250);
       }
     }, null, [], 'startDraftSimulator');
   }

   // Update draft status message
   function updateDraftStatus() {
     var statusMessage = document.getElementById('draftStatusMessage');
     var constraintMessage = document.getElementById('draftConstraintMessage');
     var statusMessage2 = document.getElementById('draftStatusMessage2');
     var constraintMessage2 = document.getElementById('draftConstraintMessage2');
     
     // Check if draft is complete
     if (currentRound > maxRounds || currentTurnIndex < 0) {
       var completeText = 'ðŸŽ‰ Draft Complete!';
       var completeColor = '#28a745';
       
       if (statusMessage) {
         statusMessage.textContent = completeText;
         statusMessage.style.color = completeColor;
       }
       if (statusMessage2) {
         statusMessage2.textContent = completeText;
         statusMessage2.style.color = completeColor;
       }
       
       if (constraintMessage) constraintMessage.textContent = '';
       if (constraintMessage2) constraintMessage2.textContent = '';
       return;
     }
     
     var currentTeam = draftOrderTeams[currentTurnIndex];
     
     if (isPlayerTurn) {
       var playerText = 'ðŸŽ¯ Your Turn (Round ' + currentRound + ') - Choose wisely!';
       var playerColor = '#2c2c54';
       var constraintText = getConstraintMessage(playerTeamName);
       
       if (statusMessage) {
         statusMessage.textContent = playerText;
         statusMessage.style.color = playerColor;
       }
       if (statusMessage2) {
         statusMessage2.textContent = playerText;
         statusMessage2.style.color = playerColor;
       }
       
       if (constraintMessage) constraintMessage.textContent = constraintText;
       if (constraintMessage2) constraintMessage2.textContent = constraintText;
     } else {
       var botText = 'â³ ' + currentTeam + ' is picking (Round ' + currentRound + ')...';
       var botColor = '#8A2BE2';
       
       // Add re-pick feedback to bot status
       if (window.lastRePickData && window.lastRePickData.triggered && window.lastRePickData.team === currentTeam) {
         if (window.lastRePickData.originalType === window.lastRePickData.finalType) {
           botText += ' Re-picked: ' + window.lastRePickData.originalType + ' â†’ ' + window.lastRePickData.finalType + ' (same)';
         } else {
           botText += ' Re-picked: ' + window.lastRePickData.originalType + ' â†’ ' + window.lastRePickData.finalType;
         }
         // Don't clear the re-pick data immediately - let it persist for visibility
         setTimeout(function() {
           window.lastRePickData = null;
         }, 1500);
       }
       
       if (statusMessage) {
         statusMessage.textContent = botText;
         statusMessage.style.color = botColor;
       }
       if (statusMessage2) {
         statusMessage2.textContent = botText;
         statusMessage2.style.color = botColor;
       }
       
       if (constraintMessage) constraintMessage.textContent = '';
       if (constraintMessage2) constraintMessage2.textContent = '';
     }
   }

   // Update all teams picks display
   function updateAllTeamsDisplay() {
     var allTeamsDisplay = document.getElementById('allTeamsPicksDisplay');
     if (!allTeamsDisplay) return;
     
     var teamsHtml = '';
     for (var i = 0; i < draftOrderTeams.length; i++) {
       var teamName = draftOrderTeams[i];
       var isPlayer = (teamName === playerTeamName);
       var isDraftComplete = (currentRound > maxRounds || currentTurnIndex < 0);
       var isCurrentTurn = !isDraftComplete && (i === currentTurnIndex);
       var picks = teamPicks[teamName] || [];
       
       var bgColor = isPlayer ? 'rgba(255, 140, 0, 0.2)' : 'rgba(255,255,255,0.3)';
       var borderColor = isPlayer ? '#ff8c00' : (isCurrentTurn ? '#8A2BE2' : '#ddd');
       var borderWidth = isCurrentTurn ? '3px' : '2px';
       
       var roundText = isCurrentTurn ? ' (Round ' + currentRound + ')' : '';
       var currentTurnText = isCurrentTurn ? 'â† Current Turn' + roundText : '';
       
       teamsHtml += '<div style="margin-bottom: 15px; padding: 15px; background: ' + bgColor + '; border-radius: 8px; border: ' + borderWidth + ' solid ' + borderColor + ';">';
       teamsHtml += '<h5 style="margin-bottom: 10px; color: #2c2c54; font-weight: 600;">';
       teamsHtml += (i + 1) + '. ' + teamName + ' ' + (isPlayer ? '(You)' : '') + ' ' + currentTurnText;
       teamsHtml += '</h5>';
       teamsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 6px;">';
       
       if (picks.length > 0) {
         for (var j = 0; j < picks.length; j++) {
           var pickName = picks[j];
           var isHero = allHeroes.includes(pickName);
           
           if (isHero) {
             var heroCardStyle = isPlayer ? 
               'border: 2px solid #ff8c00; background: linear-gradient(145deg, #fff8dc, #ffeaa7);' :
               'border: 1px solid #808080; background: linear-gradient(145deg, #f8f8f8, #e8e8e8);';
             teamsHtml += '<div class="hero-card" style="' + heroCardStyle + ' font-size: 0.85rem;">' + pickName + '</div>';
           } else {
             var aspectType = getAspectType(pickName);
             var traitStyle = '';
             // All traits use consistent blue styling
             traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
             
             var borderStyle = isPlayer ? '2px solid #ff8c00' : '1px solid #808080';
             teamsHtml += '<div class="hero-card" style="' + traitStyle + ' border: ' + borderStyle + '; font-size: 0.85rem;">' + pickName + '</div>';
           }
         }
       } else {
         teamsHtml += '<p style="color: #666; font-style: italic; font-size: 0.9rem;">No picks yet</p>';
       }
       
       teamsHtml += '</div></div>';
     }
     
     allTeamsDisplay.innerHTML = teamsHtml;
   }

   // Update available items display
   function updateAvailableItemsDisplay() {
      return safeExecute(function() {
       var availableHeroesDisplay = document.getElementById('availableHeroesDisplay');
       var availableTraitsDisplay = document.getElementById('availableTraitsDisplay');
        
       if (availableHeroesDisplay) {
         var canDraftHero = isPlayerTurn ? canTeamDraft(playerTeamName, 'hero') : true;
         var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
         
         if (allHeroes.length > 0) {
           var heroesHtml = '';
           
           // Show heroes in groups when in 4-group mode
                if (draftPoolGroups === '6' && heroGroup1.length > 0 && heroGroup2.length > 0 && heroGroup3.length > 0) {
             // Hero Group 1
             heroesHtml += '<div style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             heroesHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Hero Group 1</h4>';
             heroesHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < heroGroup1.length; i++) {
               var heroName = heroGroup1[i];
               var isDrafted = draftedHeroes.includes(heroName);
               var groupAvailable = canTeamDraftFromGroup(playerTeamName, 1);
               var isClickable = canDraftHero && isPlayerTurn && !isDrafted && groupAvailable;
               
               var style;
               if (isDrafted) {
                 style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 style = 'border: 2px solid #90EE90; background: linear-gradient(145deg, #f0fff0, #e8f5e8); cursor: pointer;';
               } else {
                 style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; cursor: not-allowed;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
               heroesHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
             }
             
             heroesHtml += '</div></div>';
             
             // Hero Group 2
             heroesHtml += '<div style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             heroesHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Hero Group 2</h4>';
             heroesHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < heroGroup2.length; i++) {
               var heroName = heroGroup2[i];
               var isDrafted = draftedHeroes.includes(heroName);
               var groupAvailable = canTeamDraftFromGroup(playerTeamName, 2);
               var isClickable = canDraftHero && isPlayerTurn && !isDrafted && groupAvailable;
               
               var style;
               if (isDrafted) {
                 style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 style = 'border: 2px solid #90EE90; background: linear-gradient(145deg, #f0fff0, #e8f5e8); cursor: pointer;';
               } else {
                 style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; cursor: not-allowed;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
               heroesHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
             }
             
             heroesHtml += '</div></div>';
             
             // Hero Group 3
             heroesHtml += '<div style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             heroesHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Hero Group 3</h4>';
             heroesHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < heroGroup3.length; i++) {
               var heroName = heroGroup3[i];
               var isDrafted = draftedHeroes.includes(heroName);
               var groupAvailable = canTeamDraftFromGroup(playerTeamName, 3);
               var isClickable = canDraftHero && isPlayerTurn && !isDrafted && groupAvailable;
               
               var style;
               if (isDrafted) {
                 style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 style = 'border: 2px solid #90EE90; background: linear-gradient(145deg, #f0fff0, #e8f5e8); cursor: pointer;';
               } else {
                 style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; cursor: not-allowed;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
               heroesHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
             }
             
             heroesHtml += '</div></div>';
             
           } else if (draftPoolGroups === '4' && heroGroup1.length > 0 && heroGroup2.length > 0) {
             // Hero Group 1
             heroesHtml += '<div style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             heroesHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Hero Group 1</h4>';
             heroesHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < heroGroup1.length; i++) {
               var heroName = heroGroup1[i];
               var isDrafted = draftedHeroes.includes(heroName);
               var groupAvailable = canTeamDraftFromGroup(playerTeamName, 1);
               var isClickable = canDraftHero && isPlayerTurn && !isDrafted && groupAvailable;
               
               var style;
               if (isDrafted) {
                 style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 style = 'border: 2px solid #90EE90; background: linear-gradient(145deg, #f0fff0, #e8f5e8); cursor: pointer;';
               } else {
                 style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; cursor: not-allowed;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
               heroesHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
             }
             
             heroesHtml += '</div></div>';
             
             // Hero Group 2
             heroesHtml += '<div style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             heroesHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Hero Group 2</h4>';
             heroesHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < heroGroup2.length; i++) {
               var heroName = heroGroup2[i];
               var isDrafted = draftedHeroes.includes(heroName);
               var groupAvailable = canTeamDraftFromGroup(playerTeamName, 2);
               var isClickable = canDraftHero && isPlayerTurn && !isDrafted && groupAvailable;
               
               var style;
               if (isDrafted) {
                 style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 style = 'border: 2px solid #90EE90; background: linear-gradient(145deg, #f0fff0, #e8f5e8); cursor: pointer;';
               } else {
                 style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; cursor: not-allowed;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
               heroesHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
             }
             
             heroesHtml += '</div></div>';
             
           }
           
           availableHeroesDisplay.innerHTML = heroesHtml;
         } else {
           availableHeroesDisplay.innerHTML = '<p style="color: #666; text-align: center;">No heroes available</p>';
         }
       }
       
       if (availableTraitsDisplay) {
         var canDraftAspect = isPlayerTurn ? canTeamDraft(playerTeamName, 'aspect') : true;
         var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
         
         if (allTraits.length > 0) {
           var aspectsHtml = '';
           
           // Show aspects in groups when in 4-group mode
           // Add 6-group mode support for 3 aspect groups
           if (draftPoolGroups === '6' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && traitsGroup3.length > 0) {
             // Get selectable aspects for each group
             var selectableGroup1 = getSelectableAspectsInGroup(1);
             var selectableGroup2 = getSelectableAspectsInGroup(2);
             var selectableGroup3 = getSelectableAspectsInGroup(3);
             
             // Traits Group 1
             aspectsHtml += '<div style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             aspectsHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Traits Group 1</h4>';
             aspectsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < traitsGroup1.length; i++) {
               var aspectName = traitsGroup1[i];
               var isDrafted = draftedTraits.includes(aspectName);
               var groupAvailable = canTeamDraftFromAspectGroup(playerTeamName, 1);
               var isSelectable = selectableGroup1.includes(aspectName);
               var isClickable = canDraftAspect && isPlayerTurn && !isDrafted && groupAvailable && isSelectable;
               
               var aspectType = getAspectType(aspectName);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               
               if (isDrafted) {
                 traitStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 traitStyle += ' cursor: pointer; border-width: 2px; border-style: solid;';
               } else {
                 traitStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
               var checkmark = '';
               
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspectName);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               
               aspectsHtml += '<div class="hero-card trait-card-multiline" data-item="' + aspectName + '" style="' + traitStyle + '" ' + onclick + '>' + multiLineContent + '</div>';
             }
             
             aspectsHtml += '</div></div>';
             
             // Traits Group 2
             aspectsHtml += '<div style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             aspectsHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Traits Group 2</h4>';
             aspectsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < traitsGroup2.length; i++) {
               var aspectName = traitsGroup2[i];
               var isDrafted = draftedTraits.includes(aspectName);
               var groupAvailable = canTeamDraftFromAspectGroup(playerTeamName, 2);
               var isSelectable = selectableGroup2.includes(aspectName);
               var isClickable = canDraftAspect && isPlayerTurn && !isDrafted && groupAvailable && isSelectable;
               
               var aspectType = getAspectType(aspectName);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               
               if (isDrafted) {
                 traitStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 traitStyle += ' cursor: pointer; border-width: 2px; border-style: solid;';
               } else {
                 traitStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
               var checkmark = '';
               
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspectName);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               
               aspectsHtml += '<div class="hero-card trait-card-multiline" data-item="' + aspectName + '" style="' + traitStyle + '" ' + onclick + '>' + multiLineContent + '</div>';
             }
             
             aspectsHtml += '</div></div>';
             
             // Traits Group 3
             aspectsHtml += '<div style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             aspectsHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Traits Group 3</h4>';
             aspectsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < traitsGroup3.length; i++) {
               var aspectName = traitsGroup3[i];
               var isDrafted = draftedTraits.includes(aspectName);
               var groupAvailable = canTeamDraftFromAspectGroup(playerTeamName, 3);
               var isSelectable = selectableGroup3.includes(aspectName);
               var isClickable = canDraftAspect && isPlayerTurn && !isDrafted && groupAvailable && isSelectable;
               
               var aspectType = getAspectType(aspectName);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               
               if (isDrafted) {
                 traitStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 traitStyle += ' cursor: pointer; border-width: 2px; border-style: solid;';
               } else {
                 traitStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
               var checkmark = '';
               
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspectName);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               
               aspectsHtml += '<div class="hero-card trait-card-multiline" data-item="' + aspectName + '" style="' + traitStyle + '" ' + onclick + '>' + multiLineContent + '</div>';
             }
             
             aspectsHtml += '</div></div>';
             
           } else if (draftPoolGroups === '4' && traitsGroup1.length > 0 && traitsGroup2.length > 0) {
             // Get selectable aspects for each group
             var selectableGroup1 = getSelectableAspectsInGroup(1);
             var selectableGroup2 = getSelectableAspectsInGroup(2);
             
             // Traits Group 1
             aspectsHtml += '<div style="margin-bottom: 25px; padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             aspectsHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Traits Group 1</h4>';
             aspectsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < traitsGroup1.length; i++) {
               var aspectName = traitsGroup1[i];
               var isDrafted = draftedTraits.includes(aspectName);
               var groupAvailable = canTeamDraftFromAspectGroup(playerTeamName, 1);
               var isSelectable = selectableGroup1.includes(aspectName);
               var isClickable = canDraftAspect && isPlayerTurn && !isDrafted && groupAvailable && isSelectable;
               
               var aspectType = getAspectType(aspectName);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               
               if (isDrafted) {
                 traitStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 traitStyle += ' cursor: pointer; border-width: 2px; border-style: solid;';
               } else {
                 traitStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
               var checkmark = '';
               
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspectName);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               
               aspectsHtml += '<div class="hero-card trait-card-multiline" data-item="' + aspectName + '" style="' + traitStyle + '" ' + onclick + '>' + multiLineContent + '</div>';
             }
             
             aspectsHtml += '</div></div>';
             
             // Traits Group 2
             aspectsHtml += '<div style="padding: 20px; border-radius: 10px; background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);">';
             aspectsHtml += '<h4 style="margin-bottom: 15px; font-size: 1.1rem; font-weight: 600; color: #2c2c54;">Traits Group 2</h4>';
             aspectsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
             
             for (var i = 0; i < traitsGroup2.length; i++) {
               var aspectName = traitsGroup2[i];
               var isDrafted = draftedTraits.includes(aspectName);
               var groupAvailable = canTeamDraftFromAspectGroup(playerTeamName, 2);
               var isSelectable = selectableGroup2.includes(aspectName);
               var isClickable = canDraftAspect && isPlayerTurn && !isDrafted && groupAvailable && isSelectable;
               
               var aspectType = getAspectType(aspectName);
               var traitStyle = '';
               // All traits use consistent blue styling
               traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
               
               if (isDrafted) {
                 traitStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed;';
               } else if (isClickable) {
                 traitStyle += ' cursor: pointer; border-width: 2px; border-style: solid;';
               } else {
                 traitStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid;';
               }
               
               var onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
               var checkmark = '';
               
               // Parse trait into 3 components for multi-line display
               var traitParts = parseTraitForDisplay(aspectName);
               var multiLineContent = 
                 '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
                 '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
                 '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
               
               aspectsHtml += '<div class="hero-card trait-card-multiline" data-item="' + aspectName + '" style="' + traitStyle + '" ' + onclick + '>' + multiLineContent + '</div>';
             }
             
             aspectsHtml += '</div></div>';
             
           }
           
           availableTraitsDisplay.innerHTML = aspectsHtml;
         } else {
           availableTraitsDisplay.innerHTML = '<p style="color: #666; text-align: center;">No traits available</p>';
         }
       }
     }, null, [], 'updateAvailableItemsDisplay');
   }

   // Update bot priority display
   function updateBotPriorityDisplay() {
     var botPriorityDisplay = document.getElementById('botPriorityDisplay');
     if (!botPriorityDisplay) return;
     
     var botPriorityInPool = filteredDraftOrder.filter(function(hero) {
       // Check for exact match or Spider-Woman variant match
       return allHeroes.includes(hero) || (hero === 'Spider-Woman' && allHeroes.some(function(h) {
         return h.startsWith('Spider-Woman - ');
       }));
     }).map(function(hero) {
       // Replace Spider-Woman with the aspect-assigned version if present
       if (hero === 'Spider-Woman') {
         var spiderWomanVariant = allHeroes.find(function(h) {
           return h.startsWith('Spider-Woman - ');
         });
         return spiderWomanVariant || hero;
       }
       return hero;
     });
     
     if (botPriorityInPool.length > 0) {
       var botHtml = '';
       for (var i = 0; i < botPriorityInPool.length; i++) {
         var heroName = botPriorityInPool[i];
         var isDrafted = draftedHeroes.includes(heroName);
         var canDraftHero = isPlayerTurn ? canTeamDraft(playerTeamName, 'hero') : true;
         var isClickable = canDraftHero && isPlayerTurn && !isDrafted;
         
         var style;
         if (isDrafted) {
           style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; font-size: 0.85rem; cursor: not-allowed;';
         } else if (isClickable) {
           style = 'border: 2px solid #8A2BE2; background: linear-gradient(145deg, #f8f0ff, #e8d5ff); font-size: 0.85rem; cursor: pointer;';
         } else {
           style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; font-size: 0.85rem; cursor: not-allowed; opacity: 0.7;';
         }
         
         var onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
         
         botHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
       }
       botPriorityDisplay.innerHTML = botHtml;
     } else {
       botPriorityDisplay.innerHTML = '<p style="color: #666; text-align: center; font-style: italic;">No bot priority heroes in current pool</p>';
     }
   }

   // Update bot aspect priority display
   function updateBotTraitsPriorityDisplay() {
     var botTraitsPriorityDisplay = document.getElementById('botTraitsPriorityDisplay');
     if (!botTraitsPriorityDisplay) return;
     
     
    if (traitsPriorityList.length > 0) {
       var aspectsHtml = '';
       
       traitsPriorityList.forEach(function(aspectName, index) {
         var isDrafted = draftedTraits.includes(aspectName);
         var canDraftAspect = isPlayerTurn ? canTeamDraft(playerTeamName, 'aspect') : true;
         var isClickable = false; // Disabled clicking in Bot Priority panel - read-only for reference
         
         var aspectType = getAspectType(aspectName);
         var traitStyle = '';
         // All traits use consistent blue styling
         traitStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
         
         if (isDrafted) {
           traitStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed; font-size: 0.85rem;';
         } else {
           // Always show as read-only (no clicking allowed in Bot Priority panel)
           traitStyle += ' opacity: 0.8; cursor: default; border-width: 2px; border-style: solid; font-size: 0.85rem;';
         }
         
         // No onclick functionality - panel is read-only for strategic reference
         var onclick = '';
         
         // Parse trait into 3 components for multi-line display
         var traitParts = parseTraitForDisplay(aspectName);
         var multiLineContent = 
           '<div class="trait-line trait-character">' + traitParts.character + '</div>' +
           '<div class="trait-line trait-hero">' + traitParts.hero + '</div>' +
           '<div class="trait-line trait-ae">' + traitParts.alterEgo + '</div>';
         
         aspectsHtml += '<div class="hero-card trait-card-multiline" data-item="' + aspectName + '" style="' + traitStyle + '" ' + onclick + '>' + multiLineContent + '</div>';
       });
       
       botTraitsPriorityDisplay.innerHTML = aspectsHtml;
     } else {
       botTraitsPriorityDisplay.innerHTML = '<p style="color: #666; text-align: center; font-style: italic;">No traits in current pool</p>';
     }
   }

   // Draft item function
   function draftItem(itemName) {
     if (!isPlayerTurn) return;
     
     var isHero = allHeroes.includes(itemName);
     var isAspect = allTraits.includes(itemName);
     
     var actualItemToDraft = itemName;
     
     if (isAspect) {
       var aspectType = getAspectType(itemName);
       
       // Fix aspect selection to respect clicked group
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       if ((draftPoolGroups === '4' || draftPoolGroups === '6') && traitsGroup1.length > 0 && traitsGroup2.length > 0 && (draftPoolGroups !== '6' || traitsGroup3.length > 0)) {
         // In group-restricted modes, use the exact clicked aspect (it's already been validated as selectable)
         actualItemToDraft = itemName;
       }
     }
     
     var alreadyDrafted = draftedHeroes.includes(actualItemToDraft) || draftedTraits.includes(actualItemToDraft);
     if (alreadyDrafted) return;
     
     var draftType = isHero ? 'hero' : 'aspect';
     if (!canTeamDraft(playerTeamName, draftType)) return;
     
     // Add group restriction validation
     // Add 6-group mode support
     var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
     if ((draftPoolGroups === '4' || draftPoolGroups === '6')) {
       if (isHero) {
         var heroGroup = getHeroGroup(actualItemToDraft);
         if (heroGroup > 0 && !canTeamDraftFromGroup(playerTeamName, heroGroup)) {
           return; // Cannot draft from this hero group
         }
       } else if (isAspect) {
         var aspectGroup = getAspectGroup(actualItemToDraft);
         if (aspectGroup > 0 && !canTeamDraftFromAspectGroup(playerTeamName, aspectGroup)) {
           return; // Cannot draft from this aspect group
         }
       }
     }
     
     var currentTeam = draftOrderTeams[currentTurnIndex];
     
     teamPicks[currentTeam].push(actualItemToDraft);
     if (isHero) {
       draftedHeroes.push(actualItemToDraft);
     } else {
       draftedTraits.push(actualItemToDraft);
     }
     
     updateAllTeamsDisplay();
     updateAvailableItemsDisplay();
     updateBotPriorityDisplay();
     updateBotTraitsPriorityDisplay();
     
     advanceTurn();
   }
   
   // Advance to next turn (snake draft format - supports 4 or 6 rounds)
   function advanceTurn() {
     
     if (currentRound === 1 || currentRound === 3 || currentRound === 5) {
       currentTurnIndex++;
       if (currentTurnIndex >= draftOrderTeams.length) {
         currentRound++;
         currentTurnIndex = draftOrderTeams.length - 1;
       }
     } else if (currentRound === 2 || currentRound === 4 || currentRound === 6) {
       currentTurnIndex--;
       if (currentTurnIndex < 0) {
         if (currentRound < maxRounds) {
           currentRound++;
           currentTurnIndex = 0;
         } else {
           currentRound = maxRounds + 1;
           updateDraftStatus();
           updateAllTeamsDisplay();
           return;
         }
       }
     }
     
     isPlayerTurn = (draftOrderTeams[currentTurnIndex] === playerTeamName);
     
     updateDraftStatus();
     updateAllTeamsDisplay();
     updateAvailableItemsDisplay();
     updateBotPriorityDisplay();
     updateBotTraitsPriorityDisplay();
     
     // Extend delay for re-pick visibility
     if (!isPlayerTurn) {
       var delay = (window.lastRePickData && window.lastRePickData.triggered) ? 2500 : 1250;
       setTimeout(processNextTurn, delay);
     }
   }
   
   // Process AI turn with enhanced bot strategy
   function processNextTurn() {
     if (isPlayerTurn) return;
     if (currentRound > maxRounds) return;
     
     var currentTeam = draftOrderTeams[currentTurnIndex];
     var aiPick = null;
     
     // Track re-pick behavior for user feedback
     var rePickTriggered = false;
     var originalPickType = '';
     var finalPickType = '';
     
     var currentTeamPicks = teamPicks[currentTeam] || [];
     var currentHeroes = currentTeamPicks.filter(function(pick) {
       return allHeroes.includes(pick);
     });
     var currentAspects = currentTeamPicks.filter(function(pick) {
       return allTraits.includes(pick);
     });
     
      // Support H-A-H-A-H-A pattern for 6-group mode
     var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
     var preferredType;
     
     if (draftPoolGroups === '6') {
       // 6-group mode: H-T-H-T-H-T pattern (Hero in R1, R3, R5; Traits in R2, R4, R6)
       preferredType = (currentRound === 1 || currentRound === 3 || currentRound === 5) ? 'hero' : 'aspect';
     } else {
       // Original logic for 4-group mode: H-T-H-T pattern (Hero in R1, R3; Traits in R2, R4)
       preferredType = (currentRound === 1 || currentRound === 3) ? 'hero' : 'aspect';
     }
     
     // Use customizable bot randomness percentage
     var randomChance = Math.random();
     if (randomChance < (botRandomnessPercentage / 100)) {
       preferredType = (preferredType === 'hero') ? 'aspect' : 'hero';
     }
     
     // Support 3 heroes and 3 aspects in 6-group mode
     var maxHeroes = draftPoolGroups === '6' ? 3 : 2;
     var maxAspects = draftPoolGroups === '6' ? 3 : 2;
     var canPickHero = currentHeroes.length < maxHeroes;
     var canPickAspect = currentAspects.length < maxAspects;
     
     if (preferredType === 'hero' && !canPickHero) {
       preferredType = 'aspect';
     } else if (preferredType === 'aspect' && !canPickAspect) {
       preferredType = 'hero';
     }
     
     if ((preferredType === 'hero' && !canPickHero) || (preferredType === 'aspect' && !canPickAspect)) {
       advanceTurn();
       return;
     }
     
     if (preferredType === 'hero') {
       var availableHeroes = allHeroes.filter(function(hero) {
         return !draftedHeroes.includes(hero);
       });
       
       // Apply group restrictions for bots in 4-group mode
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       if (draftPoolGroups === '6' && heroGroup1.length > 0 && heroGroup2.length > 0 && heroGroup3.length > 0) {
         var currentTeamHeroes = currentHeroes;
         if (currentTeamHeroes.length > 0) {
           // Filter out heroes from already-used groups
           var usedGroups = currentTeamHeroes.map(function(hero) {
             return getHeroGroup(hero);
           });
           availableHeroes = availableHeroes.filter(function(hero) {
             return !usedGroups.includes(getHeroGroup(hero));
           });
         }
         // First hero pick can be from any group (no additional filtering needed)
       } else if (draftPoolGroups === '4' && heroGroup1.length > 0 && heroGroup2.length > 0) {
         var currentTeamHeroes = currentHeroes;
         if (currentTeamHeroes.length === 1) {
           // Second hero pick - must be from opposite group
           var firstHeroGroup = getHeroGroup(currentTeamHeroes[0]);
           var allowedGroup = firstHeroGroup === 1 ? 2 : 1;
           availableHeroes = availableHeroes.filter(function(hero) {
             return getHeroGroup(hero) === allowedGroup;
           });
         }
         // First hero pick can be from any group (no additional filtering needed)
       }
       
       if (availableHeroes.length === 0) {
         advanceTurn();
         return;
       }
       
       // Check for surprise pick first
       var surpriseChance = Math.random();
       if (surpriseChance < (botSurprisePercentage / 100)) {
         // Surprise pick: completely random from all available heroes
         var randomIndex = Math.floor(Math.random() * availableHeroes.length);
         aiPick = availableHeroes[randomIndex];
       } else {
         // Normal pick: weighted selection from top 5 tier list heroes
         var availablePriorityHeroes = filteredDraftOrder.filter(function(hero) {
           // Handle Spider-Woman variant matching
           if (hero === 'Spider-Woman') {
             return availableHeroes.some(function(h) {
               return h === 'Spider-Woman' || h.startsWith('Spider-Woman - ');
             });
           }
           return availableHeroes.includes(hero);
         }).map(function(hero) {
           // Replace Spider-Woman with the actual variant in the pool
           if (hero === 'Spider-Woman') {
             var spiderWomanVariant = availableHeroes.find(function(h) {
               return h.startsWith('Spider-Woman - ');
             });
             return spiderWomanVariant || hero;
           }
           return hero;
         });
         
         if (availablePriorityHeroes.length > 0) {
           var topChoices = availablePriorityHeroes.slice(0, Math.min(5, availablePriorityHeroes.length));
           
           var weights = [];
           for (var i = 0; i < topChoices.length; i++) {
             weights.push(Math.pow(1.5, topChoices.length - 1 - i));
           }
           
           var totalWeight = weights.reduce(function(sum, weight) {
             return sum + weight;
           }, 0);
           var random = Math.random() * totalWeight;
           var cumulativeWeight = 0;
           
           for (var i = 0; i < topChoices.length; i++) {
             cumulativeWeight += weights[i];
             if (random <= cumulativeWeight) {
               aiPick = topChoices[i];
               break;
             }
           }
         } else {
           // No tier list heroes available, pick randomly
           var randomIndex = Math.floor(Math.random() * availableHeroes.length);
           aiPick = availableHeroes[randomIndex];
         }
       }
       
       if (aiPick) {
         draftedHeroes.push(aiPick);
       }
       
     } else {
       var availableAspects = allTraits.filter(function(aspect) {
         return !draftedTraits.includes(aspect);
       });
       
       // Apply aspect group restrictions for bots in 4-group mode
        // Add 6-group mode support for bot 3-aspect group restrictions
       var draftPoolGroups = document.getElementById('draftPoolGroups') ? document.getElementById('draftPoolGroups').value : DEFAULT_DRAFT_GROUPS;
       if (draftPoolGroups === '6' && traitsGroup1.length > 0 && traitsGroup2.length > 0 && traitsGroup3.length > 0) {
         var currentTeamAspects = currentAspects;
         if (currentTeamAspects.length > 0) {
           // Filter out aspects from already-used groups
           var usedGroups = currentTeamAspects.map(function(aspect) {
             return getAspectGroup(aspect);
           });
           availableAspects = availableAspects.filter(function(aspect) {
             return !usedGroups.includes(getAspectGroup(aspect));
           });
         }
         // No used groups yet - can pick from any group
       } else if (draftPoolGroups === '4' && traitsGroup1.length > 0 && traitsGroup2.length > 0) {
         var currentTeamAspects = currentAspects;
         if (currentTeamAspects.length === 1) {
           // Second aspect pick - must be from opposite group
           var firstAspectGroup = getAspectGroup(currentTeamAspects[0]);
           var allowedGroup = firstAspectGroup === 1 ? 2 : 1;
           availableAspects = availableAspects.filter(function(aspect) {
             return getAspectGroup(aspect) === allowedGroup;
           });
         }
         // First aspect pick can be from any group (no additional filtering needed)
       }
       
       if (availableAspects.length === 0) {
         advanceTurn();
         return;
       }
       
       // Check for surprise pick first
       var surpriseChance = Math.random();
       if (surpriseChance < (botSurprisePercentage / 100)) {
         // Surprise pick: completely random from all available aspects
         var randomIndex = Math.floor(Math.random() * availableAspects.length);
         var randomAspect = availableAspects[randomIndex];
         var aspectType = getAspectType(randomAspect);
         aiPick = getHighestAvailableAspect(aspectType);
       } else {
         // Leadership priority logic
         var availableLeadership = getHighestAvailableLeadership();
         if (availableLeadership) {
           // Take highest available Leadership
           aiPick = availableLeadership;
         } else {
           // Normal pick: weighted selection from top 5 priority aspects
           var availablePriorityAspects = traitsPriorityList.filter(function(aspect) {
             return availableAspects.includes(aspect);
           });
           
           if (availablePriorityAspects.length > 0) {
             var topChoices = availablePriorityAspects.slice(0, Math.min(5, availablePriorityAspects.length));
             
             var weights = [];
             for (var i = 0; i < topChoices.length; i++) {
               weights.push(Math.pow(1.5, topChoices.length - 1 - i));
             }
             
             var totalWeight = weights.reduce(function(sum, weight) {
               return sum + weight;
             }, 0);
             var random = Math.random() * totalWeight;
             var cumulativeWeight = 0;
             
             for (var i = 0; i < topChoices.length; i++) {
               cumulativeWeight += weights[i];
               if (random <= cumulativeWeight) {
                 var selectedAspect = topChoices[i];
                 var aspectType = getAspectType(selectedAspect);
                 aiPick = getHighestAvailableAspect(aspectType);
                 break;
               }
             }
           } else {
             // No priority aspects available, pick randomly
             var randomIndex = Math.floor(Math.random() * availableAspects.length);
             var randomAspect = availableAspects[randomIndex];
             var aspectType = getAspectType(randomAspect);
             aiPick = getHighestAvailableAspect(aspectType);
           }
         }
       }
       
       // Mild discouragement for duplicate aspect types on second pick
       if (currentAspects.length === 1 && aiPick && getAspectType(aiPick) === getAspectType(currentAspects[0])) {
         // Track re-pick data for user feedback
         rePickTriggered = true;
         originalPickType = getAspectType(aiPick);
         
         // Re-run aspect selection logic once to encourage variety
         var rePickChance = Math.random();
         if (rePickChance < (botSurprisePercentage / 100)) {
           // Re-pick: Surprise pick - completely random from all available aspects
           var randomIndex = Math.floor(Math.random() * availableAspects.length);
           var randomAspect = availableAspects[randomIndex];
           var aspectType = getAspectType(randomAspect);
           aiPick = getHighestAvailableAspect(aspectType);
         } else {
           // Re-pick: Leadership priority logic
           var availableLeadership = getHighestAvailableLeadership();
           if (availableLeadership && availableAspects.includes(availableLeadership)) {
             // Take highest available Leadership if still available
             aiPick = availableLeadership;
           } else {
             // Re-pick: Normal weighted selection from top 5 priority aspects
             var availablePriorityAspects = traitsPriorityList.filter(function(aspect) {
               return availableAspects.includes(aspect);
             });
             
             if (availablePriorityAspects.length > 0) {
               var topChoices = availablePriorityAspects.slice(0, Math.min(5, availablePriorityAspects.length));
               
               var weights = [];
               for (var i = 0; i < topChoices.length; i++) {
                 weights.push(Math.pow(1.5, topChoices.length - 1 - i));
               }
               
               var totalWeight = weights.reduce(function(sum, weight) {
                 return sum + weight;
               }, 0);
               var random = Math.random() * totalWeight;
               var cumulativeWeight = 0;
               
               for (var i = 0; i < topChoices.length; i++) {
                 cumulativeWeight += weights[i];
                 if (random <= cumulativeWeight) {
                   var selectedAspect = topChoices[i];
                   var aspectType = getAspectType(selectedAspect);
                   aiPick = getHighestAvailableAspect(aspectType);
                   break;
                 }
               }
             } else {
               // Re-pick: No priority aspects available, pick randomly
               var randomIndex = Math.floor(Math.random() * availableAspects.length);
               var randomAspect = availableAspects[randomIndex];
               var aspectType = getAspectType(randomAspect);
               aiPick = getHighestAvailableAspect(aspectType);
             }
           }
         }
         // Store final pick type for feedback
         finalPickType = getAspectType(aiPick);
         // Accept whatever the re-pick produces, even if still same type
       }
       
       if (aiPick) {
         draftedTraits.push(aiPick);
       }
     }
     
     if (aiPick) {
       teamPicks[currentTeam].push(aiPick);
       
       // Store re-pick data globally for status display
       window.lastRePickData = {
         triggered: rePickTriggered,
         originalType: originalPickType,
         finalType: finalPickType,
         team: currentTeam
       };
       
       // Force status update after storing re-pick data
       if (rePickTriggered) {
         updateDraftStatus(); // Force immediate status update
       }
       
       updateAllTeamsDisplay();
       updateAvailableItemsDisplay();
       updateBotPriorityDisplay();
       updateBotTraitsPriorityDisplay();
       
       advanceTurn();
     }
   }
   
   /* ===== MODOK DRAFT TOOL - MAIN SCRIPT END ===== */
   /* CRITICAL: No JavaScript code should appear after this point */
 </script>
</body>
</html>
