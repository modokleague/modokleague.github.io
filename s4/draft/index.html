<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MODOK League S4 Hero Pool Builder - Enhanced</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
      background-size: 400% 400%;
      animation: comicBg 15s ease infinite;
      color: #2c2c54;
      font-family: 'Comic Sans MS', cursive, sans-serif;
      transition: all 0.3s ease;
      min-height: 100vh;
    }

    @keyframes comicBg {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: rgba(255, 255, 255, 0.95);
      border: 4px solid #2c2c54;
      border-radius: 20px;
      position: relative;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .container::before {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: repeating-linear-gradient(
        45deg,
        #ff6b6b,
        #ff6b6b 10px,
        #feca57 10px,
        #feca57 20px
      );
      border-radius: 25px;
      z-index: -1;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-group label {
      font-weight: 600;
      font-size: 1rem;
    }

    .control-group input, .control-group select, .control-group textarea {
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    .control-group input:focus, .control-group select:focus, .control-group textarea:focus {
      outline: none;
      border-color: #4a90e2;
      box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
    }

    .btn {
      padding: 15px 30px;
      background: linear-gradient(145deg, #ff6b6b, #ee5a52);
      color: white;
      border: 3px solid #2c2c54;
      border-radius: 8px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .btn:hover {
      background: linear-gradient(145deg, #ee5a52, #e54646);
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }

    .hero-lists {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .hero-section {
      padding: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(5px);
    }

    .hero-section h3 {
      margin-bottom: 15px;
      font-size: 1.3rem;
      font-weight: 600;
    }

    .hero-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .hero-card {
      padding: 8px 12px;
      background: linear-gradient(145deg, #fff, #f0f0f0);
      border: 3px solid #2c2c54;
      border-radius: 6px;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      cursor: default;
      transform: rotate(-1deg);
    }

    .hero-card:nth-child(even) {
      transform: rotate(1deg);
    }

    .hero-card:hover {
      transform: rotate(0deg) scale(1.05);
      box-shadow: 0 10px 20px rgba(0,0,0,0.3);
    }

    .results {
      margin-top: 30px;
    }

    .result-section {
      margin-bottom: 25px;
      padding: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(5px);
    }

    .result-section h3 {
      margin-bottom: 15px;
      font-size: 1.3rem;
      font-weight: 600;
      color: #2c2c54;
    }

    .draft-order {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }

    .team-card {
      padding: 12px;
      text-align: center;
      background: rgba(74, 144, 226, 0.1);
      border-radius: 8px;
      font-weight: 600;
      border: 2px solid rgba(74, 144, 226, 0.3);
    }

    .footer-note {
      margin-top: 30px;
      padding: 15px;
      background: rgba(0,0,0,0.1);
      border-radius: 8px;
      font-size: 0.9rem;
      text-align: center;
      display: none;
    }

    .footer-note a {
      color: #2c2c54;
      text-decoration: none;
      font-weight: 600;
    }

    .footer-note a:hover {
      text-decoration: underline;
    }

    @media (max-width: 768px) {
      .container {
        padding: 15px;
        margin: 10px;
      }
      
      .header h1 {
        font-size: 2rem;
      }
      
      .controls {
        grid-template-columns: 1fr;
      }
      
      .hero-lists {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Draft-o-matic</h1>
      <p>MODOK League Season 4 (V0.8)</p>
    </div>

    <div class="hero-lists">
      <div class="hero-section">
        <h3>Available Heroes</h3>
        <div class="hero-grid" id="allHeroes"></div>
      </div>
      
      <div class="hero-section">
        <h3>Available Aspects</h3>
        <div class="hero-grid" id="allAspects"></div>
      </div>
      
      <div class="hero-section">
        <h3>Banned Heroes</h3>
        <div class="hero-grid" id="bannedHeroes"></div>
      </div>
    </div>

    <div class="controls">
      <div class="control-group">
        <label for="teamsInput">Number of Teams</label>
        <small style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">Range: 6-14 teams</small>
        <input type="number" id="teamsInput" min="6" max="14" value="10">
      </div>
      
      <div class="control-group">
        <label for="seedInput">Seed for randomization (optional)</label>
        <input type="text" id="seedInput" placeholder="For reproducible results">
      </div>
      
      <div class="control-group">
        <label for="teamListInput">Team Names (Optional)</label>
        <small style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">One team per line. <strong>First will be your team</strong> in the draft simulator. Remaining names replace default team names.</small>
        <textarea id="teamListInput" placeholder="My Team Name&#10;Team Beta&#10;Team Gamma&#10;..." style="padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1rem; resize: vertical; min-height: 80px; font-family: inherit;"></textarea>
      </div>
      
      <div class="control-group">
        <label for="extrasInput">Extras in the Draft Pool</label>
        <small id="extrasSubLabel" style="color: #666; font-size: 0.85em; margin-bottom: 8px; display: block;">Additional heroes beyond 2Ã—teams (Maximum: <span id="maxExtras">45</span>)</small>
        <input type="number" id="extrasInput" min="0" max="45" value="6">
      </div>
    </div>

    <div style="text-align: center;">
      <button class="btn" id="goButton">Generate Draft Pool</button>
    </div>

    <div class="result-section" style="margin-top: 30px;">
      <h3 style="cursor: pointer; user-select: none; transition: color 0.3s ease;" onclick="toggleChangelog()" id="changelogHeader">
        ðŸ“‹ Changelog (V0.8) <span id="changelogArrow" style="font-size: 0.8em; margin-left: 8px;">â–¼</span>
      </h3>
      <div id="changelogContent" style="display: none; padding: 15px; background: rgba(72, 219, 251, 0.1); border-radius: 8px; border: 2px solid #48dbfb; margin-top: 10px;">
        <h4 style="margin-bottom: 10px; color: #48dbfb; font-size: 1.1rem;">V0.8 - Bot Surprise Pick System</h4>
        <ul style="margin-left: 20px; color: #2c2c54;">
          <li style="margin-bottom: 8px;"><strong>Surprise Pick Slider:</strong> Added second slider for bot's chance to make completely random picks (0-100%)</li>
          <li style="margin-bottom: 8px;"><strong>Two-Stage Selection:</strong> Bots first check for surprise pick, then use weighted selection if not surprising</li>
          <li style="margin-bottom: 8px;"><strong>Complete Randomness:</strong> Surprise picks ignore tier lists entirely and choose randomly from all available options</li>
          <li style="margin-bottom: 8px;"><strong>Default 5%:</strong> Conservative default ensures occasional shocking picks without breaking strategy</li>
          <li style="margin-bottom: 8px;"><strong>Enhanced Strategy Control:</strong> Users now control both round adherence AND tier list adherence independently</li>
          <li style="margin-bottom: 8px;"><strong>Dynamic Descriptions:</strong> Both sliders update strategy descriptions in real-time</li>
          <li style="margin-bottom: 8px;"><strong>Improved Naming:</strong> Renamed first slider to "Bot Ignore Round Preferences" for clarity</li>
          <li style="margin-bottom: 8px;"><strong>Export Integration:</strong> Both bot settings included in exported draft pool files</li>
          <li style="margin-bottom: 8px;"><strong>Strategic Depth:</strong> Players can now experience everything from predictable bots to complete chaos</li>
        </ul>
        <h4 style="margin-bottom: 10px; color: #48dbfb; font-size: 1.1rem; margin-top: 15px;">V0.7 - Customizable Bot Strategy</h4>
        <ul style="margin-left: 20px; color: #2c2c54;">
          <li style="margin-bottom: 8px;"><strong>Bot Randomness Control:</strong> Added slider to adjust bot's chance to draft opposite type (0-100%)</li>
          <li style="margin-bottom: 8px;"><strong>Improved Default:</strong> Increased default bot randomness from 10% to 15% for more varied drafts</li>
          <li style="margin-bottom: 8px;"><strong>Strategy Customization:</strong> Users can now fine-tune bot behavior from predictable (0%) to chaotic (100%)</li>
          <li style="margin-bottom: 8px;"><strong>Real-time Preview:</strong> Bot strategy description updates dynamically as you adjust the slider</li>
          <li style="margin-bottom: 8px;"><strong>Enhanced Control:</strong> Full control over draft simulator difficulty and unpredictability</li>
          <li style="margin-bottom: 8px;"><strong>Export Integration:</strong> Bot randomness setting included in exported draft pool files</li>
          <li style="margin-bottom: 8px;"><strong>User Interface:</strong> Intuitive slider with visual indicators (Predictable â†’ Balanced â†’ Chaotic)</li>
        </ul>
        <h4 style="margin-bottom: 10px; color: #48dbfb; font-size: 1.1rem; margin-top: 15px;">V0.6 - Aspect Priority Early Display</h4>
        <ul style="margin-left: 20px; color: #2c2c54;">
          <li style="margin-bottom: 8px;"><strong>Early Aspect Priority:</strong> Bot aspect priority is now displayed immediately when the draft pool is generated</li>
          <li style="margin-bottom: 8px;"><strong>Better User Experience:</strong> Users can see both hero and aspect bot priorities before starting the draft simulator</li>
          <li style="margin-bottom: 8px;"><strong>Consistent Priority Order:</strong> The same aspect priority order is used throughout the entire draft process</li>
          <li style="margin-bottom: 8px;"><strong>Enhanced Export:</strong> Export function now includes the bot aspect priority section</li>
          <li style="margin-bottom: 8px;"><strong>Seeded Aspect Shuffling:</strong> Aspect priority uses the same random seed as pool generation for reproducible results</li>
          <li style="margin-bottom: 8px;"><strong>Strategic Planning:</strong> Players can now plan their draft strategy by seeing bot priorities for both heroes and aspects upfront</li>
        </ul>
        <h4 style="margin-bottom: 10px; color: #48dbfb; font-size: 1.1rem; margin-top: 15px;">V0.5 - Enhanced Bot Draft Strategy</h4>
        <ul style="margin-left: 20px; color: #2c2c54;">
          <li style="margin-bottom: 8px;"><strong>Flexible Bot Drafting:</strong> Bots now have a 10% chance to draft the opposite type (hero vs aspect) in any round</li>
          <li style="margin-bottom: 8px;"><strong>Smart Constraints:</strong> Bots still respect the 2 heroes + 2 aspects maximum rule</li>
          <li style="margin-bottom: 8px;"><strong>Advanced Aspect Priority:</strong> Added "Bot Priority (Aspects)" display with Leadership first, Pool last, and shuffled middle aspects</li>
          <li style="margin-bottom: 8px;"><strong>Weighted Aspect Selection:</strong> Bots now use the same exponential weighting system for aspects as heroes (~42% for top priority, ~28% for 2nd, etc.)</li>
          <li style="margin-bottom: 8px;"><strong>Fixed Priority Order:</strong> Aspect priority is set once per draft - no reshuffling during gameplay</li>
          <li style="margin-bottom: 8px;"><strong>Individual Instance Shuffling:</strong> Middle aspects (Aggression, Justice, Protection) are shuffled by individual numbered instances, not by type groups</li>
          <li style="margin-bottom: 8px;"><strong>Highest Number Drafting:</strong> All aspect picks (player and bot) always draft the highest numbered available instance for easy counting</li>
          <li style="margin-bottom: 8px;"><strong>Additional Status Display:</strong> Added fourth draft status box for better visibility throughout the interface</li>
        </ul>
      </div>
    </div>

    <div class="results" id="results" style="display: none;">
      <div class="result-section">
        <h3>Hero Pool</h3>
        <div class="hero-grid" id="resultPool"></div>
      </div>
      
      <div class="result-section">
        <h3>Aspect Pool</h3>
        <div class="hero-grid" id="resultAspectPool"></div>
      </div>
      
      <div class="result-section">
        <h3>Draft Bot Order (Heroes)</h3>
        <div class="hero-grid" id="resultDraftBot"></div>
      </div>
      
      <div class="result-section">
        <h3>Draft Bot Priority (Aspects)</h3>
        <div class="hero-grid" id="resultDraftBotAspects"></div>
      </div>
      
      <div class="result-section">
        <h3>Team Draft Order</h3>
        <div class="draft-order" id="resultDraftOrder"></div>
      </div>
      
      <div class="result-section">
        <h3>Excluded Heroes</h3>
        <div class="hero-grid" id="resultExcluded"></div>
      </div>
      
      <div style="text-align: center; margin-top: 30px; padding: 20px;">
        <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2;">
          <h4 style="margin-bottom: 15px; color: #8A2BE2;">Bot Strategy Settings</h4>
          
          <div style="margin-bottom: 20px;">
            <label for="botRandomnessSlider" style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c2c54;">
              Bot Ignore Round Preferences: <span id="botRandomnessValue" style="color: #8A2BE2;">15%</span>
            </label>
            <input type="range" id="botRandomnessSlider" min="0" max="100" value="15" style="width: 300px; max-width: 100%;" oninput="updateBotSettings()">
            <div style="display: flex; justify-content: space-between; max-width: 300px; margin: 5px auto 0; font-size: 0.8em; color: #666;">
              <span>0% (Predictable)</span>
              <span>50% (Balanced)</span>
              <span>100% (Chaotic)</span>
            </div>
            <p style="font-size: 0.85em; color: #666; margin: 8px 0 0; text-align: center;">Chance to ignore round preferences (Hero R1&3, Aspect R2&4)</p>
          </div>
          
          <div style="margin-bottom: 15px;">
            <label for="botSurpriseSlider" style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c2c54;">
              Bot Surprise Pick: <span id="botSurpriseValue" style="color: #ff6b6b;">5%</span>
            </label>
            <input type="range" id="botSurpriseSlider" min="0" max="100" value="5" style="width: 300px; max-width: 100%;" oninput="updateBotSettings()">
            <div style="display: flex; justify-content: space-between; max-width: 300px; margin: 5px auto 0; font-size: 0.8em; color: #666;">
              <span>0% (Tier List Only)</span>
              <span>50% (Mixed)</span>
              <span>100% (Pure Random)</span>
            </div>
            <p style="font-size: 0.85em; color: #666; margin: 8px 0 0; text-align: center;">Chance to ignore tier lists and pick completely randomly</p>
          </div>
          
          <p id="botStrategyDescription" style="color: #2c2c54; font-size: 0.9rem; margin: 0; text-align: center; font-style: italic; background: rgba(255,255,255,0.3); padding: 10px; border-radius: 6px;">
            Bots prefer Hero in R1&3, Aspect in R2&4, with 15% chance to draft opposite type. 5% chance for surprise picks.
          </p>
        </div>
        
        <button class="btn" id="exportButton" onclick="exportDraftPool()" style="font-size: 1rem; padding: 12px 25px; margin-right: 15px;">
          ðŸ“‹ Export Draft Pool
        </button>
        <button class="btn" id="startDraftButton" onclick="startDraftSimulator()" style="font-size: 1rem; padding: 12px 25px;">
          ðŸŽ¯ Start Draft Simulator
        </button>
      </div>
    </div>

    <div class="draft-setup" id="draftSetup" style="display: none;">
      <div class="result-section">
        <h3>ðŸŽ¯ Draft Simulator - Setup</h3>
        <div style="padding: 20px;">
          <div style="background: rgba(255, 107, 107, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #ff6b6b;">
            <h4 style="margin-bottom: 10px; color: #ff6b6b;">Your Team</h4>
            <p style="font-size: 1.2rem; font-weight: bold;" id="playerTeamDisplay"></p>
          </div>
          
          <div style="background: rgba(72, 219, 251, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #48dbfb;">
            <h4 style="margin-bottom: 15px; color: #48dbfb;">Draft Information</h4>
            <p style="margin-bottom: 10px;">Heroes available for draft: <strong id="heroCountDisplay"></strong></p>
            <p style="margin-bottom: 10px;">Aspects available for draft: <strong id="aspectCountDisplay"></strong></p>
            <p>Teams participating: <strong id="teamCountDisplay"></strong></p>
            <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">Each team drafts 2 heroes and 2 aspects over 4 rounds</p>
          </div>
          
          <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2; text-align: center;">
            <h4 style="margin-bottom: 10px; color: #8A2BE2; font-size: 1.2rem;">Current Draft Status</h4>
            <p id="draftStatusMessage2" style="font-size: 1.1rem; font-weight: bold; color: #2c2c54;">ðŸŽ¯ Your Turn - Click a hero or aspect to draft!</p>
            <p id="draftConstraintMessage2" style="font-size: 0.9rem; color: #666; margin-top: 8px;"></p>
          </div>
          
          <div style="background: rgba(160, 160, 160, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #a0a0a0;">
            <h4 style="margin-bottom: 15px; color: #2c2c54;">All Teams' Picks (Draft Order)</h4>
            <div id="allTeamsPicksDisplay">
              <p style="color: #666; font-style: italic;">Draft not started</p>
            </div>
          </div>
          
          <div style="background: rgba(254, 202, 87, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 30px; border: 2px solid #feca57;">
            <h4 style="margin-bottom: 15px; color: #2c2c54;">Team Draft Order</h4>
            <div id="draftOrderDisplay" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;"></div>
          </div>
          
          <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2; text-align: center;">
            <h4 style="margin-bottom: 10px; color: #8A2BE2; font-size: 1.2rem;">Draft Status</h4>
            <p id="draftStatusMessage" style="font-size: 1.1rem; font-weight: bold; color: #2c2c54;">ðŸŽ¯ Your Turn - Click a hero or aspect to draft!</p>
            <p id="draftConstraintMessage" style="font-size: 0.9rem; color: #666; margin-top: 8px;"></p>
          </div>
          
          <div style="background: rgba(144, 238, 144, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #90EE90;">
            <h4 style="margin-bottom: 15px; color: #2c2c54;">Available Heroes for Draft</h4>
            <div id="availableHeroesDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
          </div>
          
          <div style="background: rgba(255, 193, 7, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #ffc107;">
            <h4 style="margin-bottom: 15px; color: #2c2c54;">Available Aspects for Draft</h4>
            <div id="availableAspectsDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
          </div>
          
          <div style="background: rgba(138, 43, 226, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #8A2BE2;">
            <h4 style="margin-bottom: 15px; color: #2c2c54;">Bot Priority (Heroes)</h4>
            <div id="botPriorityDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
          </div>
          
          <div style="background: rgba(255, 20, 147, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #ff1493;">
            <h4 style="margin-bottom: 15px; color: #2c2c54;">Bot Priority (Aspects)</h4>
            <div id="botAspectPriorityDisplay" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
          </div>
          
          <div style="background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 30px; border: 1px solid #ffc107;">
            <p style="color: #2c2c54; font-size: 0.9rem; margin: 0; text-align: center;">
              <strong>Draft Rules:</strong> 4 rounds total. Each team picks 2 heroes and 2 aspects. You can choose heroes or aspects freely within constraints.<br>
              <strong>Bot Strategy:</strong> Two-stage system - first checks for surprise picks (random), then uses weighted tier list selection.<br>
              <strong>Hero Priority:</strong> Bots use weighted selection from tier list (~38% top choice, ~26% 2nd choice, etc.). Surprise picks ignore tier lists.<br>
              <strong>Aspect Priority:</strong> Leadership first, Pool last, middle aspects shuffled. Same weighted selection as heroes.
            </p>
          </div>
        </div>
      </div>
    </div>

    <div class="footer-note" id="footerNote">
      Draft-bot order is based on <a href="https://www.youtube.com/watch?v=2bRm-ZxtNjM" target="_blank">Villain Theory's May 2025 tierlist</a>
    </div>
  </div>

  <script>
    // Global variables
    let aspectPriorityList = [];
    let currentTurnIndex = 0;
    let currentRound = 1;
    let maxRounds = 4;
    let draftOrderTeams = [];
    let playerTeamName = '';
    let teamPicks = {};
    let isPlayerTurn = false;
    let draftedHeroes = [];
    let draftedAspects = [];
    let allHeroes = [];
    let allAspects = [];
    let botRandomnessPercentage = 15; // Default 15% randomness
    let botSurprisePercentage = 5; // Default 5% surprise picks

    // Update bot settings (both sliders)
    function updateBotSettings() {
      const randomnessSlider = document.getElementById('botRandomnessSlider');
      const surpriseSlider = document.getElementById('botSurpriseSlider');
      const randomnessValue = document.getElementById('botRandomnessValue');
      const surpriseValue = document.getElementById('botSurpriseValue');
      const description = document.getElementById('botStrategyDescription');
      
      botRandomnessPercentage = parseInt(randomnessSlider.value);
      botSurprisePercentage = parseInt(surpriseSlider.value);
      
      randomnessValue.textContent = botRandomnessPercentage + '%';
      surpriseValue.textContent = botSurprisePercentage + '%';
      
      // Generate combined strategy description
      let roundText = '';
      if (botRandomnessPercentage === 0) {
        roundText = 'Bots always follow strict pattern: Hero in R1&3, Aspect in R2&4';
      } else if (botRandomnessPercentage <= 25) {
        roundText = `Bots prefer Hero in R1&3, Aspect in R2&4, with ${botRandomnessPercentage}% chance to draft opposite type`;
      } else if (botRandomnessPercentage <= 75) {
        roundText = `Bots have ${botRandomnessPercentage}% chance to ignore round preferences`;
      } else {
        roundText = `Bots mostly ignore round preferences (${botRandomnessPercentage}% chaos)`;
      }
      
      let surpriseText = '';
      if (botSurprisePercentage === 0) {
        surpriseText = 'Always use tier list priorities';
      } else if (botSurprisePercentage <= 10) {
        surpriseText = `${botSurprisePercentage}% chance for shocking surprise picks`;
      } else if (botSurprisePercentage <= 25) {
        surpriseText = `${botSurprisePercentage}% chance to ignore tier lists completely`;
      } else if (botSurprisePercentage <= 50) {
        surpriseText = `${botSurprisePercentage}% chance for random picks (mixed strategy)`;
      } else {
        surpriseText = `${botSurprisePercentage}% chance for random picks (mostly chaos)`;
      }
      
      description.textContent = roundText + '. ' + surpriseText + '.';
    }

    // Helper function to get aspect type from numbered aspect
    function getAspectType(numberedAspect) {
      return numberedAspect.split(' #')[0];
    }

    // Initialize aspect priority order
    function initializeAspectPriorityOrder(useRandomSeed = true, rng = null) {
      const aspectsByType = {};
      allAspects.forEach(aspect => {
        const aspectType = getAspectType(aspect);
        if (!aspectsByType[aspectType]) {
          aspectsByType[aspectType] = [];
        }
        aspectsByType[aspectType].push(aspect);
      });
      
      Object.keys(aspectsByType).forEach(type => {
        aspectsByType[type].sort((a, b) => {
          const numA = parseInt(a.split('#')[1]);
          const numB = parseInt(b.split('#')[1]);
          return numB - numA;
        });
      });
      
      aspectPriorityList = [];
      
      if (aspectsByType['Leadership']) {
        aspectPriorityList.push(...aspectsByType['Leadership']);
      }
      
      const middleInstances = [];
      ['Aggression', 'Justice', 'Protection'].forEach(aspectType => {
        if (aspectsByType[aspectType]) {
          middleInstances.push(...aspectsByType[aspectType]);
        }
      });
      
      if (useRandomSeed && rng) {
        shuffleArray(middleInstances, rng);
      } else {
        for (let i = middleInstances.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [middleInstances[i], middleInstances[j]] = [middleInstances[j], middleInstances[i]];
        }
      }
      
      aspectPriorityList.push(...middleInstances);
      
      if (aspectsByType['Pool']) {
        aspectPriorityList.push(...aspectsByType['Pool']);
      }
    }

    // Banned heroes
    const bannedHeroes = [];

    // Available aspects
    const availableAspects = [
      'Aggression', 'Justice', 'Leadership', 'Protection', 'Pool'
    ];

    // Bot draft order
    const draftOrder = [
      'Spider-Ham', 'Cable', 'Cyclops', 'Storm', 'Magik', 'Psylocke', 'Maria Hill',
      'Bishop', 'Spider-Man (Peter Parker)', 'Doctor Strange', 'Spider-Man (Miles Morales)',
      'Captain Marvel', 'Scarlet Witch', 'X-23', 'Deadpool',
      'Black Panther (Shuri)', 'Magneto', 'Ironheart', 'Vision', 'Captain America', 
      'Domino', 'Angel', 'Shadowcat', 'Nova',
      'Nick Fury', 'Iron Man', 'Silk', 'Spider-Woman', 'SP//dr',
      'Phoenix', 'Wolverine', 'Venom', 'Rogue', "Black Panther (T'Challa)",
      'Ant-Man', 'Star-Lord', 'Spectrum', 'Colossus', 'Jubilee', 
      'Gambit', 'Iceman', 'Rocket',
      'Falcon', 'Winter Soldier',
      'Adam Warlock', 'Gamora', 'Ghost-Spider', 'Drax', 'Black Widow', 'Nightcrawler', 'Wasp',
      'Ms Marvel', 'Nebula', 'She-Hulk', 'Thor', 'War Machine', 'Quicksilver',
      'Hawkeye', 'Groot', 'Valkyrie', 'Hulk'
    ];

    // Toggle changelog
    function toggleChangelog() {
      const content = document.getElementById('changelogContent');
      const header = document.getElementById('changelogHeader');
      const arrow = document.getElementById('changelogArrow');
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        arrow.textContent = 'â–²';
        header.style.color = '#48dbfb';
      } else {
        content.style.display = 'none';
        arrow.textContent = 'â–¼';
        header.style.color = '#2c2c54';
      }
    }

    // Check if hero is banned
    function isHeroBanned(heroName) {
      if (bannedHeroes.includes(heroName)) return true;
      const heroBaseName = heroName.split(' - ')[0];
      for (const bannedHero of bannedHeroes) {
        const bannedBaseName = bannedHero.split(' - ')[0];
        if (heroBaseName === bannedBaseName) return true;
      }
      return false;
    }

    const filteredDraftOrder = draftOrder.filter(hero => !isHeroBanned(hero));
    const marvelHeroes = [...filteredDraftOrder].sort();

    // Team name pools
    const teamNamePools = {
      0: ['Aaron Davis', 'Abigail Brand', 'Adrian Toomes', 'Amora', 'Arnim Zola'],
      1: ['Betty Ross', 'Bullseye', 'Bruno Carrelli', 'Baron Mordo', 'Beetle', 'Black Tom Cassidy', 'Black Swan', 'Boomerang', 'Betty Brant'],
      2: ['Calvin Zabo', 'Cassandra Nova', 'Curt Connors', 'Clea', 'Carl "Crusher" Creel', 'Cassie Lang', 'Colleen Wing'],
      3: ['Doctor Doom', 'Donald Pierce', 'Dormammu', 'Daken', 'Danny Rand', 'Donald Blake'],
      4: ['Edwin Jarvis', 'Elektra', 'Emil Blonsky', 'Everett Ross', 'Ebony Maw', 'Eddie Brock', 'Exodus', 'Ego the Living Planet'],
      5: ['Felicia Hardy', 'Fin Fang Foom', 'Frank Castle', 'Franklin Richards', 'Frigga', 'Foggy Nelson'],
      6: ['Gwen Stacy', 'George Stacy', 'Gorgon', 'Giganto', 'Gilgamesh', 'Grandmaster', 'Gorr'],
      7: ['Harry Osborn', 'Howard Stark', 'Hope Pym', 'Hobgoblin', 'Helmut Zemo', 'Happy Hogan', 'Howard the Duck', 'Husk', 'High Evolutionary'],
      8: ['Illyana Rasputin', 'Imperial Guard', 'Iron Fist'],
      9: ['J Jonah Jameson', 'Janet Van Dyne', 'Jessica Jones', 'Jacosta', 'Jamie Madrox', 'Jimmy Woo', 'Johnny Blaze', 'Jessica Drew'],
      10: ['Karnak', 'Kurt Wagner', 'Kitty Pryde', 'Kaluu', 'Kamala Khan', 'Kang the Conqueror', 'Kid Omega', 'Killmonger', 'Kingpin', 'Klaw'],
      11: ['Laufey', 'Leo Fitz', 'Lucia von Bardas', 'Luke Cage', 'Loki', 'Lizard', 'Lorna Dane', 'Logan']
    };

    // Random number generator
    class Random {
      constructor(seed = Math.random()) {
        if (typeof seed === 'string') {
          this.seed = this.stringToHash(seed);
        } else {
          this.seed = this.hash(seed.toString());
        }
      }

      stringToHash(str) {
        if (str === '') return 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }

      hash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }

      next() {
        this.seed = (1664525 * this.seed + 1013904223) >>> 0;
        return this.seed / 0xFFFFFFFF;
      }
    }

    function shuffleArray(array, rng) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(rng.next() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Initialize display
    document.getElementById('allHeroes').innerHTML = marvelHeroes.map(hero => 
      '<div class="hero-card">' + hero + '</div>'
    ).join('');
    
    document.getElementById('allAspects').innerHTML = availableAspects.map(aspect => {
      let aspectStyle = '';
      switch(aspect.toLowerCase()) {
        case 'aggression':
          aspectStyle = 'background: linear-gradient(145deg, #ffe8e8, #ffcaca); border-color: #ff6b6b; color: #d63447;';
          break;
        case 'justice':
          aspectStyle = 'background: linear-gradient(145deg, #fff8dc, #ffeaa7); border-color: #feca57; color: #f39800;';
          break;
        case 'leadership':
          aspectStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
          break;
        case 'protection':
          aspectStyle = 'background: linear-gradient(145deg, #e8f5e8, #c8e6c8); border-color: #55a55a; color: #2d8f2f;';
          break;
        case 'pool':
          aspectStyle = 'background: linear-gradient(145deg, #ffe8ff, #ffcaff); border-color: #ff9ff3; color: #e84393;';
          break;
        default:
          aspectStyle = 'background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border-color: #888; color: #555;';
      }
      return '<div class="hero-card" style="' + aspectStyle + '">' + aspect + '</div>';
    }).join('');
    
    document.getElementById('bannedHeroes').innerHTML = bannedHeroes.map(hero => 
      '<div class="hero-card">' + hero + '</div>'
    ).join('');

    // Update max extras
    function updateMaxExtras() {
      const numberOfTeams = parseInt(document.getElementById('teamsInput').value) || 10;
      const maxExtras = marvelHeroes.length - (2 * numberOfTeams);
      document.getElementById('maxExtras').textContent = maxExtras;
      
      const extrasInput = document.getElementById('extrasInput');
      extrasInput.setAttribute('max', maxExtras);
      
      const currentValue = parseInt(extrasInput.value) || 6;
      if (currentValue > maxExtras) {
        extrasInput.value = maxExtras;
      }
    }
    
    updateMaxExtras();
    document.getElementById('teamsInput').addEventListener('input', updateMaxExtras);

    // Generate pool button event listener
    document.getElementById('goButton').addEventListener('click', function() {
      const seedInput = document.getElementById('seedInput').value;
      const rng = new Random(seedInput || Math.random());
      
      const numberOfTeams = parseInt(document.getElementById('teamsInput').value);
      const numberOfExtras = parseInt(document.getElementById('extrasInput').value) || 6;
      
      const numberOfHeroes = (2 * numberOfTeams) + numberOfExtras;

      if (numberOfHeroes > marvelHeroes.length) {
        alert('Pool size too large! Maximum extras possible: ' + (marvelHeroes.length - (2 * numberOfTeams)));
        return;
      }

      // Generate hero pool
      const heroesPool = [...marvelHeroes];
      shuffleArray(heroesPool, rng);

      const selectedHeroes = heroesPool.slice(0, numberOfHeroes).sort();
      const excludedHeroes = heroesPool.slice(numberOfHeroes).sort();
      
      // Generate aspect pool
      const aspectPool = [];
      const mainAspects = ['Aggression', 'Justice', 'Leadership', 'Protection'];
      
      for (let i = 0; i < numberOfHeroes; i++) {
        const randomAspect = mainAspects[Math.floor(rng.next() * mainAspects.length)];
        aspectPool.push(randomAspect);
      }
      
      aspectPool.push('Pool', 'Pool', 'Pool', 'Pool');
      
      // Number aspects
      const numberedAspectPool = [];
      
      ['Aggression', 'Justice', 'Leadership', 'Protection', 'Pool'].forEach(aspectType => {
        const instances = aspectPool.filter(aspect => aspect === aspectType);
        for (let i = 0; i < instances.length; i++) {
          numberedAspectPool.push(aspectType + ' #' + (instances.length - i));
        }
      });

      allAspects = [...numberedAspectPool];
      initializeAspectPriorityOrder(true, rng);

      const draftBot = filteredDraftOrder.filter(hero => selectedHeroes.includes(hero));

      // Get custom teams
      const customTeamList = document.getElementById('teamListInput').value.trim();
      const customTeams = customTeamList ? customTeamList.split('\n').map(name => name.trim()).filter(name => name.length > 0) : [];
      
      const userTeamName = customTeams.length > 0 ? customTeams[0] : '';
      const numberOfActualTeams = userTeamName ? numberOfTeams - 1 : numberOfTeams;
      
      const teams = Array.from({ length: numberOfActualTeams }, (_, i) => {
        const customIndex = i + 1;
        if (customIndex < customTeams.length) {
          return customTeams[customIndex];
        }
        
        if (teamNamePools[i]) {
          const namePool = [...teamNamePools[i]];
          const randomIndex = Math.floor(rng.next() * namePool.length);
          return namePool[randomIndex];
        } else {
          return 'Team ' + String.fromCharCode(65 + i);
        }
      });
      
      if (userTeamName) {
        teams.push(userTeamName);
      }
      
      shuffleArray(teams, rng);

      // Display results
      document.getElementById('resultPool').innerHTML = selectedHeroes.map(hero => 
        '<div class="hero-card">' + hero + '</div>'
      ).join('');
      
      document.getElementById('resultAspectPool').innerHTML = numberedAspectPool.map(aspect => {
        const aspectType = getAspectType(aspect);
        let aspectStyle = '';
        switch(aspectType.toLowerCase()) {
          case 'aggression':
            aspectStyle = 'background: linear-gradient(145deg, #ffe8e8, #ffcaca); border-color: #ff6b6b; color: #d63447;';
            break;
          case 'justice':
            aspectStyle = 'background: linear-gradient(145deg, #fff8dc, #ffeaa7); border-color: #feca57; color: #f39800;';
            break;
          case 'leadership':
            aspectStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
            break;
          case 'protection':
            aspectStyle = 'background: linear-gradient(145deg, #e8f5e8, #c8e6c8); border-color: #55a55a; color: #2d8f2f;';
            break;
          case 'pool':
            aspectStyle = 'background: linear-gradient(145deg, #ffe8ff, #ffcaff); border-color: #ff9ff3; color: #e84393;';
            break;
          default:
            aspectStyle = 'background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border-color: #888; color: #555;';
        }
        return '<div class="hero-card" style="' + aspectStyle + '">' + aspect + '</div>';
      }).join('');
      
      document.getElementById('resultDraftBot').innerHTML = draftBot.map(hero => 
        '<div class="hero-card">' + hero + '</div>'
      ).join('');
      
      // Display bot aspect priority
      document.getElementById('resultDraftBotAspects').innerHTML = aspectPriorityList.map(aspect => {
        const aspectType = getAspectType(aspect);
        let aspectStyle = '';
        switch(aspectType.toLowerCase()) {
          case 'aggression':
            aspectStyle = 'background: linear-gradient(145deg, #ffe8e8, #ffcaca); border-color: #ff6b6b; color: #d63447;';
            break;
          case 'justice':
            aspectStyle = 'background: linear-gradient(145deg, #fff8dc, #ffeaa7); border-color: #feca57; color: #f39800;';
            break;
          case 'leadership':
            aspectStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
            break;
          case 'protection':
            aspectStyle = 'background: linear-gradient(145deg, #e8f5e8, #c8e6c8); border-color: #55a55a; color: #2d8f2f;';
            break;
          case 'pool':
            aspectStyle = 'background: linear-gradient(145deg, #ffe8ff, #ffcaff); border-color: #ff9ff3; color: #e84393;';
            break;
          default:
            aspectStyle = 'background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border-color: #888; color: #555;';
        }
        return '<div class="hero-card" style="' + aspectStyle + '">' + aspect + '</div>';
      }).join('');
      
      document.getElementById('resultDraftOrder').innerHTML = teams.map((team, index) => 
        '<div class="team-card">' + (index + 1) + '. ' + team + '</div>'
      ).join('');
      
      document.getElementById('resultExcluded').innerHTML = excludedHeroes.map(hero => 
        '<div class="hero-card">' + hero + '</div>'
      ).join('');

      document.getElementById('results').style.display = 'block';
      document.getElementById('footerNote').style.display = 'block';
      
      document.getElementById('results').scrollIntoView({ behavior: 'smooth' });
    });

    // Helper functions for draft simulator
    function getHighestAvailableAspect(aspectType) {
      const availableInstances = allAspects.filter(aspect => {
        const currentType = getAspectType(aspect);
        return currentType === aspectType && !draftedAspects.includes(aspect);
      });
      
      if (availableInstances.length === 0) return null;
      
      availableInstances.sort((a, b) => {
        const numA = parseInt(a.split('#')[1]);
        const numB = parseInt(b.split('#')[1]);
        return numB - numA;
      });
      
      return availableInstances[0];
    }

    function canTeamDraft(teamName, draftType) {
      const picks = teamPicks[teamName] || [];
      const heroes = picks.filter(pick => allHeroes.includes(pick));
      const aspects = picks.filter(pick => allAspects.includes(pick));
      
      if (draftType === 'hero') {
        return heroes.length < 2;
      } else if (draftType === 'aspect') {
        return aspects.length < 2;
      }
      return false;
    }
    
    function getConstraintMessage(teamName) {
      const picks = teamPicks[teamName] || [];
      const heroes = picks.filter(pick => allHeroes.includes(pick));
      const aspects = picks.filter(pick => allAspects.includes(pick));
      
      const heroesLeft = 2 - heroes.length;
      const aspectsLeft = 2 - aspects.length;
      
      if (heroesLeft === 0) {
        return "You must pick an aspect (no heroes remaining)";
      } else if (aspectsLeft === 0) {
        return "You must pick a hero (no aspects remaining)";
      } else {
        return "You can pick either a hero (" + heroesLeft + " left) or aspect (" + aspectsLeft + " left)";
      }
    }

    // Export function
    function exportDraftPool() {
      const heroCards = document.getElementById('resultPool').children;
      const aspectCards = document.getElementById('resultAspectPool').querySelectorAll('.hero-card');
      const teamCards = document.getElementById('resultDraftOrder').children;
      const excludedCards = document.getElementById('resultExcluded').children;
      const draftBotCards = document.getElementById('resultDraftBot').children;
      const draftBotAspectCards = document.getElementById('resultDraftBotAspects').children;
      
      if (heroCards.length === 0) {
        alert('Please generate a draft pool first!');
        return;
      }
      
      const numberOfTeams = document.getElementById('teamsInput').value;
      const numberOfExtras = document.getElementById('extrasInput').value;
      const seedUsed = document.getElementById('seedInput').value || 'Random';
      const customTeamList = document.getElementById('teamListInput').value.trim();
      const customTeams = customTeamList ? customTeamList.split('\n').map(name => name.trim()).filter(name => name.length > 0) : [];
      const userTeam = customTeams.length > 0 ? customTeams[0] : 'None';
      
      let exportText = '';
      exportText += '='.repeat(50) + '\n';
      exportText += '    MODOK LEAGUE SEASON 4 - DRAFT POOL\n';
      exportText += '='.repeat(50) + '\n';
      exportText += 'Generated: ' + new Date().toLocaleString() + '\n';
      exportText += 'Tool Version: V0.8\n';
      exportText += 'Teams: ' + numberOfTeams + '\n';
      exportText += 'Extras: ' + numberOfExtras + '\n';
      exportText += 'Seed: ' + seedUsed + '\n';
      exportText += 'Bot Ignore Round Preferences: ' + botRandomnessPercentage + '%\n';
      exportText += 'Bot Surprise Pick: ' + botSurprisePercentage + '%\n';
      exportText += 'User Team: ' + userTeam + '\n';
      if (customTeamList) {
        exportText += 'Custom Teams Used: Yes\n';
      }
      exportText += '\n';
      
      exportText += 'HERO POOL (' + heroCards.length + ' heroes)\n';
      exportText += '-'.repeat(30) + '\n';
      for (let i = 0; i < heroCards.length; i++) {
        exportText += heroCards[i].textContent + '\n';
      }
      exportText += '\n';
      
      exportText += 'ASPECT POOL (' + aspectCards.length + ' aspects)\n';
      exportText += '-'.repeat(30) + '\n';
      
      const aspectCounts = {};
      for (let i = 0; i < aspectCards.length; i++) {
        const aspectText = aspectCards[i].textContent;
        if (aspectText.includes('#')) {
          const aspectType = aspectText.split(' #')[0];
          aspectCounts[aspectType] = (aspectCounts[aspectType] || 0) + 1;
        }
      }
      
      Object.keys(aspectCounts).forEach(aspectType => {
        exportText += aspectType + ': ' + aspectCounts[aspectType] + '\n';
      });
      exportText += '\n';
      
      exportText += 'TEAM DRAFT ORDER\n';
      exportText += '-'.repeat(30) + '\n';
      for (let i = 0; i < teamCards.length; i++) {
        const teamText = teamCards[i].textContent;
        const teamName = teamText.split('. ')[1];
        exportText += teamName + '\n';
      }
      exportText += '\n';
      
      exportText += 'DRAFT BOT PRIORITY (Heroes in Pool)\n';
      exportText += '-'.repeat(30) + '\n';
      for (let i = 0; i < draftBotCards.length; i++) {
        exportText += draftBotCards[i].textContent + '\n';
      }
      exportText += '\n';
      
      exportText += 'DRAFT BOT PRIORITY (Aspects)\n';
      exportText += '-'.repeat(30) + '\n';
      for (let i = 0; i < draftBotAspectCards.length; i++) {
        exportText += draftBotAspectCards[i].textContent + '\n';
      }
      exportText += '\n';
      
      if (excludedCards.length > 0) {
        exportText += 'EXCLUDED HEROES (' + excludedCards.length + ' heroes)\n';
        exportText += '-'.repeat(30) + '\n';
        for (let i = 0; i < excludedCards.length; i++) {
          exportText += excludedCards[i].textContent + '\n';
        }
        exportText += '\n';
      }
      
      exportText += '='.repeat(50) + '\n';
      exportText += 'Generated with Draft-o-matic V0.6\n';
      exportText += 'MODOK League Season 4\n';
      exportText += '='.repeat(50);
      
      const blob = new Blob([exportText], { type: 'text/plain' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'MODOK_S4_Draft_Pool_' + new Date().toISOString().split('T')[0] + '.txt';
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }

    // Draft simulator functions
    function startDraftSimulator() {
      // Get custom team names to determine user team
      const customTeamList = document.getElementById('teamListInput').value.trim();
      const customTeams = customTeamList ? customTeamList.split('\n').map(name => name.trim()).filter(name => name.length > 0) : [];
      const userTeamName = customTeams.length > 0 ? customTeams[0] : '';
      
      const heroCards = document.getElementById('resultPool').children;
      const aspectCards = document.getElementById('resultAspectPool').querySelectorAll('.hero-card');
      const teamCards = document.getElementById('resultDraftOrder').children;
      
      let playerTeam = userTeamName;
      if (!playerTeam) {
        const aTeamPool = ['Aaron Davis', 'Abigail Brand', 'Adrian Toomes', 'Amora', 'Arnim Zola'];
        
        for (let i = 0; i < teamCards.length; i++) {
          const teamText = teamCards[i].textContent;
          const teamName = teamText.split('. ')[1];
          
          if (aTeamPool.includes(teamName)) {
            playerTeam = teamName;
            break;
          }
        }
        
        if (!playerTeam && teamCards.length > 0) {
          const firstTeamText = teamCards[0].textContent;
          playerTeam = firstTeamText.split('. ')[1];
        }
      }
      
      allHeroes = [];
      draftedHeroes = [];
      draftedAspects = [];
      
      for (let i = 0; i < heroCards.length; i++) {
        allHeroes.push(heroCards[i].textContent);
      }
      
      playerTeamName = playerTeam;
      draftOrderTeams = [];
      teamPicks = {};
      for (let i = 0; i < teamCards.length; i++) {
        const teamText = teamCards[i].textContent;
        const teamName = teamText.split('. ')[1];
        draftOrderTeams.push(teamName);
        teamPicks[teamName] = [];
      }
      
      currentTurnIndex = 0;
      currentRound = 1;
      isPlayerTurn = (draftOrderTeams[currentTurnIndex] === playerTeamName);
      
      // Initialize displays
      updateAllTeamsDisplay();
      updateAvailableItemsDisplay();
      updateBotPriorityDisplay();
      updateBotAspectPriorityDisplay();
      
      // Update the display elements
      const playerDisplay = document.getElementById('playerTeamDisplay');
      const heroDisplay = document.getElementById('heroCountDisplay');
      const aspectDisplay = document.getElementById('aspectCountDisplay');
      const teamDisplay = document.getElementById('teamCountDisplay');
      
      if (playerDisplay) playerDisplay.textContent = playerTeam || 'Unknown Team';
      if (heroDisplay) heroDisplay.textContent = heroCards.length;
      if (aspectDisplay) aspectDisplay.textContent = allAspects.length;
      if (teamDisplay) teamDisplay.textContent = teamCards.length;
      
      // Show team draft order
      const draftDisplay = document.getElementById('draftOrderDisplay');
      if (draftDisplay) {
        let draftOrderHtml = '';
        for (let i = 0; i < teamCards.length; i++) {
          const teamText = teamCards[i].textContent;
          const teamName = teamText.split('. ')[1];
          const isPlayerTeam = (teamName === playerTeam);
          
          draftOrderHtml += '<div style="padding: 8px; background: ' + (isPlayerTeam ? 'rgba(255, 107, 107, 0.2)' : 'rgba(255,255,255,0.3)') + '; border-radius: 6px; text-align: center; font-weight: ' + (isPlayerTeam ? 'bold' : 'normal') + '; border: ' + (isPlayerTeam ? '2px solid #ff6b6b' : '1px solid #ddd') + ';">' + teamText + '</div>';
        }
        draftDisplay.innerHTML = draftOrderHtml;
      }
      
      // Show draft setup
      const draftSetupElement = document.getElementById('draftSetup');
      if (draftSetupElement) {
        draftSetupElement.style.display = 'block';
        draftSetupElement.scrollIntoView({ behavior: 'smooth' });
      }
      
      // Start the draft
      updateDraftStatus();
      updateAvailableItemsDisplay();
      updateBotPriorityDisplay();
      updateBotAspectPriorityDisplay();
      
      // If the first turn is a bot turn, start the bot picking process
      if (!isPlayerTurn) {
        setTimeout(processNextTurn, 1250);
      }
    }

    // Update draft status message
    function updateDraftStatus() {
      const statusMessage = document.getElementById('draftStatusMessage');
      const constraintMessage = document.getElementById('draftConstraintMessage');
      const statusMessage2 = document.getElementById('draftStatusMessage2');
      const constraintMessage2 = document.getElementById('draftConstraintMessage2');
      
      // Check if draft is complete
      if (currentRound > maxRounds || currentTurnIndex < 0) {
        const completeText = 'ðŸŽ‰ Draft Complete!';
        const completeColor = '#28a745';
        
        if (statusMessage) {
          statusMessage.textContent = completeText;
          statusMessage.style.color = completeColor;
        }
        if (statusMessage2) {
          statusMessage2.textContent = completeText;
          statusMessage2.style.color = completeColor;
        }
        
        if (constraintMessage) constraintMessage.textContent = '';
        if (constraintMessage2) constraintMessage2.textContent = '';
        return;
      }
      
      const currentTeam = draftOrderTeams[currentTurnIndex];
      
      if (isPlayerTurn) {
        const playerText = 'ðŸŽ¯ Your Turn (Round ' + currentRound + ') - Choose wisely!';
        const playerColor = '#2c2c54';
        const constraintText = getConstraintMessage(playerTeamName);
        
        if (statusMessage) {
          statusMessage.textContent = playerText;
          statusMessage.style.color = playerColor;
        }
        if (statusMessage2) {
          statusMessage2.textContent = playerText;
          statusMessage2.style.color = playerColor;
        }
        
        if (constraintMessage) constraintMessage.textContent = constraintText;
        if (constraintMessage2) constraintMessage2.textContent = constraintText;
      } else {
        const botText = 'â³ ' + currentTeam + ' is picking (Round ' + currentRound + ')...';
        const botColor = '#8A2BE2';
        
        if (statusMessage) {
          statusMessage.textContent = botText;
          statusMessage.style.color = botColor;
        }
        if (statusMessage2) {
          statusMessage2.textContent = botText;
          statusMessage2.style.color = botColor;
        }
        
        if (constraintMessage) constraintMessage.textContent = '';
        if (constraintMessage2) constraintMessage2.textContent = '';
      }
    }

    // Update all teams picks display
    function updateAllTeamsDisplay() {
      const allTeamsDisplay = document.getElementById('allTeamsPicksDisplay');
      if (!allTeamsDisplay) return;
      
      let teamsHtml = '';
      for (let i = 0; i < draftOrderTeams.length; i++) {
        const teamName = draftOrderTeams[i];
        const isPlayer = (teamName === playerTeamName);
        const isDraftComplete = (currentRound > maxRounds || currentTurnIndex < 0);
        const isCurrentTurn = !isDraftComplete && (i === currentTurnIndex);
        const picks = teamPicks[teamName] || [];
        
        const bgColor = isPlayer ? 'rgba(255, 140, 0, 0.2)' : 'rgba(255,255,255,0.3)';
        const borderColor = isPlayer ? '#ff8c00' : (isCurrentTurn ? '#8A2BE2' : '#ddd');
        const borderWidth = isCurrentTurn ? '3px' : '2px';
        
        const roundText = isCurrentTurn ? ' (Round ' + currentRound + ')' : '';
        const currentTurnText = isCurrentTurn ? 'â† Current Turn' + roundText : '';
        
        teamsHtml += '<div style="margin-bottom: 15px; padding: 15px; background: ' + bgColor + '; border-radius: 8px; border: ' + borderWidth + ' solid ' + borderColor + ';">';
        teamsHtml += '<h5 style="margin-bottom: 10px; color: #2c2c54; font-weight: 600;">';
        teamsHtml += (i + 1) + '. ' + teamName + ' ' + (isPlayer ? '(You)' : '') + ' ' + currentTurnText;
        teamsHtml += '</h5>';
        teamsHtml += '<div style="display: flex; flex-wrap: wrap; gap: 6px;">';
        
        if (picks.length > 0) {
          for (let j = 0; j < picks.length; j++) {
            const pickName = picks[j];
            const isHero = allHeroes.includes(pickName);
            
            if (isHero) {
              const heroCardStyle = isPlayer ? 
                'border: 2px solid #ff8c00; background: linear-gradient(145deg, #fff8dc, #ffeaa7);' :
                'border: 1px solid #808080; background: linear-gradient(145deg, #f8f8f8, #e8e8e8);';
              teamsHtml += '<div class="hero-card" style="' + heroCardStyle + ' font-size: 0.85rem;">' + pickName + '</div>';
            } else {
              const aspectType = getAspectType(pickName);
              let aspectStyle = '';
              switch(aspectType.toLowerCase()) {
                case 'aggression':
                  aspectStyle = 'background: linear-gradient(145deg, #ffe8e8, #ffcaca); border-color: #ff6b6b; color: #d63447;';
                  break;
                case 'justice':
                  aspectStyle = 'background: linear-gradient(145deg, #fff8dc, #ffeaa7); border-color: #feca57; color: #f39800;';
                  break;
                case 'leadership':
                  aspectStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
                  break;
                case 'protection':
                  aspectStyle = 'background: linear-gradient(145deg, #e8f5e8, #c8e6c8); border-color: #55a55a; color: #2d8f2f;';
                  break;
                case 'pool':
                  aspectStyle = 'background: linear-gradient(145deg, #ffe8ff, #ffcaff); border-color: #ff9ff3; color: #e84393;';
                  break;
                default:
                  aspectStyle = 'background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border-color: #888; color: #555;';
              }
              
              const borderStyle = isPlayer ? '2px solid #ff8c00' : '1px solid #808080';
              teamsHtml += '<div class="hero-card" style="' + aspectStyle + ' border: ' + borderStyle + '; font-size: 0.85rem;">' + pickName + '</div>';
            }
          }
        } else {
          teamsHtml += '<p style="color: #666; font-style: italic; font-size: 0.9rem;">No picks yet</p>';
        }
        
        teamsHtml += '</div></div>';
      }
      
      allTeamsDisplay.innerHTML = teamsHtml;
    }

    // Update available items display
    function updateAvailableItemsDisplay() {
      const availableHeroesDisplay = document.getElementById('availableHeroesDisplay');
      const availableAspectsDisplay = document.getElementById('availableAspectsDisplay');
      
      if (availableHeroesDisplay) {
        const canDraftHero = isPlayerTurn ? canTeamDraft(playerTeamName, 'hero') : true;
        
        if (allHeroes.length > 0) {
          let heroesHtml = '';
          for (let i = 0; i < allHeroes.length; i++) {
            const heroName = allHeroes[i];
            const isDrafted = draftedHeroes.includes(heroName);
            const isClickable = canDraftHero && isPlayerTurn && !isDrafted;
            
            let style;
            if (isDrafted) {
              style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; cursor: not-allowed;';
            } else if (isClickable) {
              style = 'border: 2px solid #90EE90; background: linear-gradient(145deg, #f0fff0, #e8f5e8); cursor: pointer;';
            } else {
              style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; cursor: not-allowed;';
            }
            
            const onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
            
            heroesHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
          }
          availableHeroesDisplay.innerHTML = heroesHtml;
        } else {
          availableHeroesDisplay.innerHTML = '<p style="color: #666; text-align: center;">No heroes available</p>';
        }
      }
      
      if (availableAspectsDisplay) {
        const canDraftAspect = isPlayerTurn ? canTeamDraft(playerTeamName, 'aspect') : true;
        
        if (allAspects.length > 0) {
          let aspectsHtml = '';
          for (let i = 0; i < allAspects.length; i++) {
            const aspectName = allAspects[i];
            const isDrafted = draftedAspects.includes(aspectName);
            const isClickable = canDraftAspect && isPlayerTurn && !isDrafted;
            
            const aspectType = getAspectType(aspectName);
            let aspectStyle = '';
            switch(aspectType.toLowerCase()) {
              case 'aggression':
                aspectStyle = 'background: linear-gradient(145deg, #ffe8e8, #ffcaca); border-color: #ff6b6b; color: #d63447;';
                break;
              case 'justice':
                aspectStyle = 'background: linear-gradient(145deg, #fff8dc, #ffeaa7); border-color: #feca57; color: #f39800;';
                break;
              case 'leadership':
                aspectStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
                break;
              case 'protection':
                aspectStyle = 'background: linear-gradient(145deg, #e8f5e8, #c8e6c8); border-color: #55a55a; color: #2d8f2f;';
                break;
              case 'pool':
                aspectStyle = 'background: linear-gradient(145deg, #ffe8ff, #ffcaff); border-color: #ff9ff3; color: #e84393;';
                break;
              default:
                aspectStyle = 'background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border-color: #888; color: #555;';
            }
            
            if (isDrafted) {
              aspectStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed;';
            } else if (isClickable) {
              aspectStyle += ' cursor: pointer; border-width: 2px; border-style: solid;';
            } else {
              aspectStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid;';
            }
            
            const onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
            
            aspectsHtml += '<div class="hero-card" data-item="' + aspectName + '" style="' + aspectStyle + '" ' + onclick + '>' + aspectName + '</div>';
          }
          availableAspectsDisplay.innerHTML = aspectsHtml;
        } else {
          availableAspectsDisplay.innerHTML = '<p style="color: #666; text-align: center;">No aspects available</p>';
        }
      }
    }

    // Update bot priority display
    function updateBotPriorityDisplay() {
      const botPriorityDisplay = document.getElementById('botPriorityDisplay');
      if (!botPriorityDisplay) return;
      
      const botPriorityInPool = filteredDraftOrder.filter(hero => allHeroes.includes(hero));
      
      if (botPriorityInPool.length > 0) {
        let botHtml = '';
        for (let i = 0; i < botPriorityInPool.length; i++) {
          const heroName = botPriorityInPool[i];
          const isDrafted = draftedHeroes.includes(heroName);
          const canDraftHero = isPlayerTurn ? canTeamDraft(playerTeamName, 'hero') : true;
          const isClickable = canDraftHero && isPlayerTurn && !isDrafted;
          
          let style;
          if (isDrafted) {
            style = 'border: 2px solid #ccc; background: #f0f0f0; color: #888; opacity: 0.6; font-size: 0.85rem; cursor: not-allowed;';
          } else if (isClickable) {
            style = 'border: 2px solid #8A2BE2; background: linear-gradient(145deg, #f8f0ff, #e8d5ff); font-size: 0.85rem; cursor: pointer;';
          } else {
            style = 'border: 2px solid #ddd; background: linear-gradient(145deg, #f8f8f8, #f0f0f0); color: #666; font-size: 0.85rem; cursor: not-allowed; opacity: 0.7;';
          }
          
          const onclick = isClickable ? 'onclick="draftItem(\'' + heroName.replace(/'/g, "\\'") + '\')"' : '';
          
          botHtml += '<div class="hero-card" data-item="' + heroName + '" style="' + style + '" ' + onclick + '>' + heroName + '</div>';
        }
        botPriorityDisplay.innerHTML = botHtml;
      } else {
        botPriorityDisplay.innerHTML = '<p style="color: #666; text-align: center; font-style: italic;">No bot priority heroes in current pool</p>';
      }
    }

    // Update bot aspect priority display
    function updateBotAspectPriorityDisplay() {
      const botAspectPriorityDisplay = document.getElementById('botAspectPriorityDisplay');
      if (!botAspectPriorityDisplay) return;
      
      if (aspectPriorityList.length > 0) {
        let aspectsHtml = '';
        
        aspectPriorityList.forEach(aspectName => {
          const isDrafted = draftedAspects.includes(aspectName);
          const canDraftAspect = isPlayerTurn ? canTeamDraft(playerTeamName, 'aspect') : true;
          const isClickable = canDraftAspect && isPlayerTurn && !isDrafted;
          
          const aspectType = getAspectType(aspectName);
          let aspectStyle = '';
          switch(aspectType.toLowerCase()) {
            case 'aggression':
              aspectStyle = 'background: linear-gradient(145deg, #ffe8e8, #ffcaca); border-color: #ff6b6b; color: #d63447;';
              break;
            case 'justice':
              aspectStyle = 'background: linear-gradient(145deg, #fff8dc, #ffeaa7); border-color: #feca57; color: #f39800;';
              break;
            case 'leadership':
              aspectStyle = 'background: linear-gradient(145deg, #e8f4fd, #b8e6ff); border-color: #48dbfb; color: #0984e3;';
              break;
            case 'protection':
              aspectStyle = 'background: linear-gradient(145deg, #e8f5e8, #c8e6c8); border-color: #55a55a; color: #2d8f2f;';
              break;
            case 'pool':
              aspectStyle = 'background: linear-gradient(145deg, #ffe8ff, #ffcaff); border-color: #ff9ff3; color: #e84393;';
              break;
            default:
              aspectStyle = 'background: linear-gradient(145deg, #f0f0f0, #e0e0e0); border-color: #888; color: #555;';
          }
          
          if (isDrafted) {
            aspectStyle = 'background: #f0f0f0; border: 2px solid #ccc; color: #888; opacity: 0.6; cursor: not-allowed; font-size: 0.85rem;';
          } else if (isClickable) {
            aspectStyle += ' cursor: pointer; border-width: 2px; border-style: solid; font-size: 0.85rem;';
          } else {
            aspectStyle += ' opacity: 0.7; cursor: not-allowed; border-width: 2px; border-style: solid; font-size: 0.85rem;';
          }
          
          const onclick = isClickable ? 'onclick="draftItem(\'' + aspectName.replace(/'/g, "\\'") + '\')"' : '';
          
          aspectsHtml += '<div class="hero-card" data-item="' + aspectName + '" style="' + aspectStyle + '" ' + onclick + '>' + aspectName + '</div>';
        });
        
        botAspectPriorityDisplay.innerHTML = aspectsHtml;
      } else {
        botAspectPriorityDisplay.innerHTML = '<p style="color: #666; text-align: center; font-style: italic;">No aspects in current pool</p>';
      }
    }

    // Draft item function
    function draftItem(itemName) {
      if (!isPlayerTurn) return;
      
      const isHero = allHeroes.includes(itemName);
      const isAspect = allAspects.includes(itemName);
      
      let actualItemToDraft = itemName;
      
      if (isAspect) {
        const aspectType = getAspectType(itemName);
        const highestAvailable = getHighestAvailableAspect(aspectType);
        if (!highestAvailable) return;
        actualItemToDraft = highestAvailable;
      }
      
      const alreadyDrafted = draftedHeroes.includes(actualItemToDraft) || draftedAspects.includes(actualItemToDraft);
      if (alreadyDrafted) return;
      
      const draftType = isHero ? 'hero' : 'aspect';
      if (!canTeamDraft(playerTeamName, draftType)) return;
      
      const currentTeam = draftOrderTeams[currentTurnIndex];
      
      teamPicks[currentTeam].push(actualItemToDraft);
      if (isHero) {
        draftedHeroes.push(actualItemToDraft);
      } else {
        draftedAspects.push(actualItemToDraft);
      }
      
      updateAllTeamsDisplay();
      updateAvailableItemsDisplay();
      updateBotPriorityDisplay();
      updateBotAspectPriorityDisplay();
      
      advanceTurn();
    }
    
    // Advance to next turn (snake draft format for 4 rounds)
    function advanceTurn() {
      if (currentRound === 1 || currentRound === 3) {
        currentTurnIndex++;
        if (currentTurnIndex >= draftOrderTeams.length) {
          currentRound++;
          currentTurnIndex = draftOrderTeams.length - 1;
        }
      } else if (currentRound === 2 || currentRound === 4) {
        currentTurnIndex--;
        if (currentTurnIndex < 0) {
          if (currentRound < maxRounds) {
            currentRound++;
            currentTurnIndex = 0;
          } else {
            currentRound = 5;
            updateDraftStatus();
            updateAllTeamsDisplay();
            return;
          }
        }
      }
      
      isPlayerTurn = (draftOrderTeams[currentTurnIndex] === playerTeamName);
      
      updateDraftStatus();
      updateAllTeamsDisplay();
      updateAvailableItemsDisplay();
      updateBotPriorityDisplay();
      updateBotAspectPriorityDisplay();
      
      if (!isPlayerTurn) {
        setTimeout(processNextTurn, 1250);
      }
    }
    
    // Process AI turn with enhanced bot strategy
    function processNextTurn() {
      if (isPlayerTurn) return;
      if (currentRound > maxRounds) return;
      
      const currentTeam = draftOrderTeams[currentTurnIndex];
      let aiPick = null;
      
      const currentTeamPicks = teamPicks[currentTeam] || [];
      const currentHeroes = currentTeamPicks.filter(pick => allHeroes.includes(pick));
      const currentAspects = currentTeamPicks.filter(pick => allAspects.includes(pick));
      
      let preferredType = (currentRound === 1 || currentRound === 3) ? 'hero' : 'aspect';
      
      // V0.7 Enhancement: Use customizable bot randomness percentage
      const randomChance = Math.random();
      if (randomChance < (botRandomnessPercentage / 100)) {
        preferredType = (preferredType === 'hero') ? 'aspect' : 'hero';
      }
      
      const canPickHero = currentHeroes.length < 2;
      const canPickAspect = currentAspects.length < 2;
      
      if (preferredType === 'hero' && !canPickHero) {
        preferredType = 'aspect';
      } else if (preferredType === 'aspect' && !canPickAspect) {
        preferredType = 'hero';
      }
      
      if ((preferredType === 'hero' && !canPickHero) || (preferredType === 'aspect' && !canPickAspect)) {
        advanceTurn();
        return;
      }
      
      if (preferredType === 'hero') {
        const availableHeroes = allHeroes.filter(hero => !draftedHeroes.includes(hero));
        
        if (availableHeroes.length === 0) {
          advanceTurn();
          return;
        }
        
        // V0.8 Enhancement: Check for surprise pick first
        const surpriseChance = Math.random();
        if (surpriseChance < (botSurprisePercentage / 100)) {
          // Surprise pick: completely random from all available heroes
          const randomIndex = Math.floor(Math.random() * availableHeroes.length);
          aiPick = availableHeroes[randomIndex];
        } else {
          // Normal pick: weighted selection from top 5 tier list heroes
          const availablePriorityHeroes = filteredDraftOrder.filter(hero => availableHeroes.includes(hero));
          
          if (availablePriorityHeroes.length > 0) {
            const topChoices = availablePriorityHeroes.slice(0, Math.min(5, availablePriorityHeroes.length));
            
            const weights = [];
            for (let i = 0; i < topChoices.length; i++) {
              weights.push(Math.pow(1.5, topChoices.length - 1 - i));
            }
            
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            const random = Math.random() * totalWeight;
            let cumulativeWeight = 0;
            
            for (let i = 0; i < topChoices.length; i++) {
              cumulativeWeight += weights[i];
              if (random <= cumulativeWeight) {
                aiPick = topChoices[i];
                break;
              }
            }
          } else {
            // No tier list heroes available, pick randomly
            const randomIndex = Math.floor(Math.random() * availableHeroes.length);
            aiPick = availableHeroes[randomIndex];
          }
        }
        
        if (aiPick) {
          draftedHeroes.push(aiPick);
        }
        
      } else {
        const availableAspects = allAspects.filter(aspect => !draftedAspects.includes(aspect));
        
        if (availableAspects.length === 0) {
          advanceTurn();
          return;
        }
        
        // V0.8 Enhancement: Check for surprise pick first
        const surpriseChance = Math.random();
        if (surpriseChance < (botSurprisePercentage / 100)) {
          // Surprise pick: completely random from all available aspects
          const randomIndex = Math.floor(Math.random() * availableAspects.length);
          const randomAspect = availableAspects[randomIndex];
          const aspectType = getAspectType(randomAspect);
          aiPick = getHighestAvailableAspect(aspectType);
        } else {
          // Normal pick: weighted selection from top 5 priority aspects
          const availablePriorityAspects = aspectPriorityList.filter(aspect => availableAspects.includes(aspect));
          
          if (availablePriorityAspects.length > 0) {
            const topChoices = availablePriorityAspects.slice(0, Math.min(5, availablePriorityAspects.length));
            
            const weights = [];
            for (let i = 0; i < topChoices.length; i++) {
              weights.push(Math.pow(1.5, topChoices.length - 1 - i));
            }
            
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            const random = Math.random() * totalWeight;
            let cumulativeWeight = 0;
            
            for (let i = 0; i < topChoices.length; i++) {
              cumulativeWeight += weights[i];
              if (random <= cumulativeWeight) {
                const selectedAspect = topChoices[i];
                const aspectType = getAspectType(selectedAspect);
                aiPick = getHighestAvailableAspect(aspectType);
                break;
              }
            }
          } else {
            // No priority aspects available, pick randomly
            const randomIndex = Math.floor(Math.random() * availableAspects.length);
            const randomAspect = availableAspects[randomIndex];
            const aspectType = getAspectType(randomAspect);
            aiPick = getHighestAvailableAspect(aspectType);
          }
        }
        
        if (aiPick) {
          draftedAspects.push(aiPick);
        }
      }
      
      if (aiPick) {
        teamPicks[currentTeam].push(aiPick);
        
        updateAllTeamsDisplay();
        updateAvailableItemsDisplay();
        updateBotPriorityDisplay();
        updateBotAspectPriorityDisplay();
        
        advanceTurn();
      }
    }
  </script>
</body>
</html>
  </script>
</body>
</html>
